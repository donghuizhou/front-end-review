**本质上，webpack 是一个用于现代 JavaScript 的静态模块打包工具，当 webpack 处理应用程序时，它会在内部从一个或多个入口构建依赖图，然后将项目中所需的每个模块组合成一个或多个 bundles。**

## Loader 和 Plugin 的区别？

`Loader` ：`Webpack` 将一切文件视为模块，但是 `webpack` 原生是只能解析 `js` 文件，如果想将其他文件也打包的话，就会用到 `loader` 。 所以 `Loader` 的作用是让 `webpack` 拥有了加载和解析非 `JavaScript` 文件的能力。

`Plugin` 可以扩展 `Webpack` 的功能，在 `Webpack` 运行的生命周期中会广播出许多事件，`Plugin` 可以监听这些事件，在合适的时机通过 `Webpack` 提供的 API 改变输出结果。

`Loader` 在 `module.rules` 中配置，作为模块的解析规则，类型为数组。每一项都是一个 `Object` ，内部包含了 `test` (类型文件)、`loader`、`options` (参数)等属性。

`Plugin` 在 `plugins` 中单独配置，类型为数组，每一项是一个 `Plugin` 的实例，参数都通过构造函数传入。

## 有哪些常见的 Loader？

- **raw-loader**：将文件作为字符串导入。

- **file-loader**：在 `JavaScript` 代码里 `import/require` 一个文件时，会将该文件生成到输出目录，并且在 `JavaScript` 代码里返回该文件的地址。

    ```javascript
    module: {
        rules: [
            {
                test: /\.(png|jpg|gif)/i,
                use: {
                    loader: "file-loader",
                    options: {}
                }
            }
        ]
    }
    ```

    ```javascript
    import logo from "../assets/image/logo.png";
    console.log("logo的值: " + logo);
    ```

    如果使用了 `file-loader` ，`dist` 目录下就会生成我们用到的那个文件，在这就是 `logo.png` ，默认情况下，生成到 `dist` 目录的文件不会是原文件名，而是 **[原文件内容的MD5哈希值].[原文件扩展名]**。

    所以上面打印出来的结果就是：

    ```javascript
    logo的值：dab1fd6b179f2dd87254d6e0f9f8efab.png
    ```

- **url-loader**：与 `file-loader` 类似，区别是用户可以设置一个阈值，大于阈值时返回其 `publicPath`，小于阈值时返回文件 `base64` 形式编码 (处理图片和字体)

    ```javascript
    {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
            limit: 10000,
            name: 'img/[name].[hash:7].[ext]'
        }
    }
    ```

    

> file-loader 和 url-loader 的差异在于，url-loader 可以设置图片的大小限制，当图片超过限制时，其表现行为等同于 file-loader，而当图片不超过限制时，则会将图片以 base64 的形式打包进 css，以减少请求次数。

- **babel-loader**：把 ES6 代码转成 ES5。

    ```javascript
    {
        test: /\.js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
            loader: 'babel-loader',
            options: {
                presets: ['@babel/preset-env']
            }
        }
    }
    ```

- **css-loader**：加载 `CSS` 文件，支持模块化、压缩、文件导入等特性。

- **style-loader**：把 `CSS` 插入到 `DOM` 中，方法是在 `head` 中插入一个 `style` 标签，并把样式写入这个标签的 `innerHTML` 中。

    ```javascript
    {
        test: /\.css$/i,
        use: ["style-loader", "css-loader"],
    },
    ```

- **less-loader**：将 `less` 编译成 `css` 的 loader。

    ```javascript
    {
        test: /\.less$/i,
        use: ["style-loader", "css-loader", "less-loader"]
    },
    ```

- **postcss-loader**：扩展 `CSS` 语法，使用下一代 `CSS` ，可以配合 `autoprefixer` 插件自动补齐 `CSS` 前缀。

- **eslint-loader**：通过 `ESLint` 检查 `JavaScript` 代码。

    ```javascript
    {
        test: /\.(js|jsx)/i,
        exclude: /node_modules/,
        use: ["babel-loader", "eslint-loader"]
    }
    ```

- **vue-loader**：加载 `Vue.js` 单文件组件。

## 有哪些常见的 Plugin？

- **html-webpack-plugin**：简化 `HTML` 文件创建。

    ```javascript
    plugins: [
        new HtmlWebpackPlugin()
    ]
    ```

    会产生一个包含以下内容的文件 `dist/index.html`：

    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>webpack App</title>
      </head>
      <body>
        <script src="index_bundle.js"></script>
      </body>
    </html>
    ```

- **~~uglifyjs-webpack-plugin~~**：使用 `uglify-js` 对 `js` 文件进行压缩。(需要 `webpack4.0.0`)。(**不支持ES6语法**)

    它使用**单线程**压缩代码，当有多个js文件需要压缩时，它需要一个个进行压缩，所以在**正式环境打包压缩速度非常慢**。

    > 因为压缩JS代码需要先把代码解析成用Object抽象表示的AST语法树，再去应用各种规则分析和处理AST，导致这个过程耗时非常大

    优点是支持老项目，对于维护比较老的项目，是较优的选择

    ```javascript
    const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
    
    module.exports = {
        optimization: {
            minimizer: [new UglifyJsPlugin()]
        }
    }
    ```

- **~~webpack-parallel-uglify-plugin~~**：会开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，但是每个子进程还是通过 `UglifyJs` 去压缩代码，无非就是变成了并行处理，效率会提高。但是这个插件不是 `Webpack` 官方维护，已经不维护了，而且不支持老项目。

    ```javascript
    const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');
    
    module.exports = {
        plugins: [
            new ParallelUglifyPlugin()
        ]
    }
    ```

- **terser-webpack-plugin**：压缩 js 文件。并行处理多个子任务，效率会更加的提高，并且是 `webpack4` 官方推荐。（**支持ES6语法**）

    ```javascript
    const TerserPlugin = require('terser-webpack-plugin');
    
    module.exports = {
        optimization: {
            minimizer: [new TerserPlugin()],
        }
    };
    ```

- **~~extra-text-webpack-plugin~~**：将 css 模块和 js 模块 分开打包，就是把 css 代码从 js 文件中抽离出来，单独出一个模块。

    > webpack 本身只能打包处理 js 文件，但是通过强大的 loader 之后，就可以打包处理各类型的文件了，比如 .css文件等。但是在 css 的内容都被打包进 bundle.js 里面了。那么问题来了：
    >
    > 我们只要修改 js 部分的代码，那么 css 模块也会被重新打包，被当成 css 模块也有内容修改。
    >
    > 只修改了 css 模块，js 模块没有变化，但是他们都在一个 bundle 中，所以都会被认为有修改。
    >
    > 所以才会用到上面的插件来做 css 抽离。

    ```javascript
    const ExtractTextPlugin = require("extract-text-webpack-plugin");
    
    module.exports = {
        module: {
            rules: [
                {
                    test: /\.css$/i,
                    use: ExtractTextPlugin.extract({
                        fallback: "style-loader",
                        use: "css-loader"
                    })
                }
            ]
        },
        plugins: [
            new ExtractTextPlugin({
                filename: "css/[name].[contenthash].css",
                allChunks: true
            })
        ]
    }
    ```

    `extract-text-webpack-plugin` 插件的缺点：

    1. 额外的HTTP请求
    2. 更长的编译时间
    3. 没有运行时（runtime）的公共路径修改
    4. 没有热替换

    **webpack 4.0以后，官方推荐使用mini-css-extract-plugin插件来打包css文件（从css文件中提取css代码到单独的文件中，对css代码进行代码压缩等）。**

- **mini-css-extract-plugin**：分离样式文件，把CSS 提取为独立文件，支持按需加载。（只有`webpack4.0` 支持）。

    ```javascript
    const MiniCssExtractPlugin = require("mini-css-extract-plugin");
    const devMode = process.env.NODE_ENV !== 'production'
    
    module.exports = {
        module: {
            rules: [
                {
                    test: /\.(css|less)$/i,
                    use: [
                        {
                            loader: MiniCssExtractPlugin.loader,
                            options: {
                                publicPath: "./",
                                hmr: devMode
                            }
                        },
                        "css-loader",
                        "less-loader"
                    ]
                }
            ]
        },
        plugins: [
            new MiniCssExtractPlugin({
                filename: devMode ? 'css/[name].css' : 'css/[name].[hash].css',
                chunkFilename: devMode ? 'css/[id].css' : 'css/[id].[hash].css',
            })
        ]
    }
    ```

- **serviceworker-webpack-plugin**：为网页应用增加离线缓存功能。

- **SplitChunksPlugin **：进行（公共脚本、基础包、页面公共文件）分离（webpack4内置），替代了 `CommonsChunkPlugin` 插件。

- **DllPlugin**：把第三方库代码分离开，且每次文件更改的时候，只会打包该项目自身的代码，所以打包速度会更快。

    在用 `Webpack` 打包时，对于一些不经常更新的第三方库，比如：`react` 、`vue` 、`lodash` ，我们希望能和自己的代码分离开。`Webpack` 社区有两种的方案：

    1. `CommonsChunkPlugin`
    2. `DLLPlugin`

    对于 `CommonsChunkPlugin` , `webpack` 每次打包实际还是需要去处理这些第三方库，只是打包完之后，能把第三方库和我们自己的代码分开。而 `DLLPlugin` 则是能把第三方代码完全分离开，即每次只打包项目自身的代码。

### webpack 的构建流程？



