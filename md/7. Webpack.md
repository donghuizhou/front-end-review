## 入口(entry)

**入口起点**(entry point)指示 `webpack` 应该使用哪个模块，来作为构建起内部依赖图的开始，进入入口起点后，`webpack` 会炸出有哪些模块和库（直接或间接）依赖的。

```javascript
module.exports = {
    entry: './path/to/my/entry/file.js',
};
```

## 输出(output)

`output` 属性告诉 `webpack` 在哪里输出它所创建的 `bundle` ，以及如何命名这些文件。

```javascript
const path = require('path');

module.exports = {
    entry: './path/to/my/entry/file.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'my-first-webpack.bundle.js',
    },
};
```

## loader

`webpack` 只能理解 `javascript` 和 `json` 文件，这是 `webpack` 自带的能力，`loader` 让 `webpack` 能够去处理其他类型的文件，并将他们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。

`loader` 有两个属性：

1. `test` 属性，识别出哪些文件会被转换
2. `use` 属性，定义出在进行转换时，应该使用哪个 `loader` 

```javascript
module.exports = {
    module: {
        rules: [
            { test: /\.text$/, use: "raw-loader" }
        ]
    }
};
```

>“嘿，webpack编辑器，当你碰到在 require() / import 语句中被解析为 .txt 的路径时，在你对它打包之前，先使用 use raw-loader 转换一下”

## 插件

`loader` 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化、资源管理、注入环境变量。

想要使用一个插件，只需要 `require()` 它，然后把它添加到 `plugins` 数组中。多数插件可以通过选项 `options` 自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这是需要通过使用 `new` 操作符来创建一个插件实例。

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装
const webpack = require('webpack'); // 用于访问内置插件

module.exports = {
    module: {
        rules: [{ test: /\.txt$/, use: 'raw-loader' }],
    },
    plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })],
};
```

## 模式(mode)

通过选择 `development` 、`production` 、或 `none` 之中的一个，来设置 `mode` 参数，可以启用 `webpack` 内置在相应环境下的优化。其默认值为 `production` 。

```javascript
module.exports = {
    mode: 'production',
};
```

## source map

当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。例如，如果将三个源文件（`a.js`, `b.js` 和 `c.js`）打包到一个 bundle（`bundle.js`）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会直接指向到 `bundle.js`。你可能需要准确地知道错误来自于哪个源文件。

为了更容易地追踪 error 和 warning，JavaScript 提供了 `source maps` 功能，可以将编译后的代码映射回原始源代码。如果一个错误来自于 `b.js`，source map 就会明确的告诉你。

## 缓存

通过缓存，可以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。

我们可以通过替换 `output.filename` 中的 [substitutions](https://webpack.docschina.org/configuration/output/#outputfilename) 设置，来定义输出文件的名称。webpack 提供了一种使用称为 **substitution(可替换模板字符串)** 的方式，通过带括号字符串来模板化文件名。其中，`[contenthash]` substitution 将根据资源内容创建出唯一 `hash`。当资源内容发生变化时，`[contenthash]` 也会发生变化。

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    entry: './src/index.js',
    plugins: [
        new HtmlWebpackPlugin({
            title: 'Output Management',
            title: 'Caching',
        }),
    ],
    output: {
        filename: 'bundle.js',
        filename: '[name].[contenthash].js',
        path: path.resolve(__dirname, 'dist'),
        clean: true,
    },
};
```

使用此配置，然后运行我们的 build script `npm run build`，产生以下输出：

```javascript
...
                       Asset       Size  Chunks                    Chunk Names
main.7e2c49a622975ebd9b7e.js     544 kB       0  [emitted]  [big]  main
                  index.html  197 bytes          [emitted]
...
```

