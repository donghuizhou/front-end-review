## web 性能优化

1. 资源压缩合并，减少`HTTP`请求和文件下载时的体积
2. `gzip` 压缩
3. 去除 `SourceMap` （由于打包后的文件经过了压缩、合并、混淆、`babel` 编译后的代码不利于定位分析 `bug` 。）
4. 非核心代码异步加载 
5. 利用浏览器缓存 
6. 使用 `CDN`
7. 预解析 `DNS`
8. 骨架屏

## CDN原理

由于用户访问源站业务有性能瓶颈，通过cdn技术把源站的内容缓存到多个节点。用户向源站域名发起请求时，请求会被调度至最接近用户的服务节点，直接由服务节点直接快速响应，有效降低用户访问延迟，提升可用性。

## 缓存

[彻底弄懂HTTP缓存机制及原理](https://www.cnblogs.com/chenqf/p/6386163.html)

为方便理解，我们认为**浏览器存在一个缓存数据库**,用于存储缓存信息。

在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。

![第一次请求数据](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141639213-1923993391.png)

`HTTP` 缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我们将其分为两大类：**强制缓存、对比缓存**。

**强制缓存请求数据的流程**

![强制缓存](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210135521072-1812985836.png)

**对比缓存请求数据的流程**

![对比缓存](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141716838-764535017.png)

根据上图可以看到，**强制缓存如果生效，不需要再和服务期发生交互，而对比缓存不管是否生效，都需要和服务器发生交互。**

两种缓存规则可以同时存在，**强制缓存**优先级高于**对比缓存**。也就是说，当执行**强制缓存**的规则时，如果缓存生效，直接使用缓存，不再执行**对比缓存**规则。

### 强制缓存

在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是**如何判断缓存数据是否失效呢？**

我们知道，在没有缓存数据时，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，**缓存规则信息包含在响应header中**。

对于强制缓存来说，响应 `header`中会有两个字段来标明失效规则（**Expires / Cache-Control**）。

#### Expires

`Expires` 的值为服务器返回的到期时间。即下一次请求时，请求时间小于服务端返回的到期时间，则直接使用缓存数据。

> 不过Expires是 HTTP 1.0 的东西，现在浏览器均默认使用 HTTP 1.1 ，所以它的作用基本忽略。
>
> 还有一个问题，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差，所以 HTTP 1.1 使用 Cache-Control 替代

#### Cache-Control

`Cache-Control` 是最重要的规则。常见的取值有 `private` 、`public` 、`max-age`、`no-cache`  、`no-store`，默认为 `private`。

| 值          | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| private     | 客户端可以缓存                                               |
| public      | 客户端和代理服务器都可以缓存（前端的同学，可以认为 `public` 和 `private` 是一样的） |
| max-age=xxx | 缓存的内容将在xxx秒后失效                                    |
| no-cache    | 需要使用对比缓存来验证缓存数据                               |
| no-store    | 所有内容都不会缓存，强制缓存、对比缓存都不会触发             |

举个栗子

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141836104-1513192908.png)

图中的 `Cache-Control`仅指定了 `max-age`，所以默认为 `private`，缓存时间为31536000秒。

### 对比缓存

顾名思义，需要进行比较判断是否可以使用缓存。

浏览器**第一次请求数据时**，服务器会**将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库**。

再次请求时，客户端**将备份的缓存标识发送给服务器**，**服务器根据缓存标识进行判断**，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

**对于对比缓存来说，缓存标识的传递是我们着重需要理解的**，它在请求header和响应header间进行传递，
一共分为两种标识传递：

#### Last-Modified / If-Modified-Since

##### Last-Modified

服务器在响应请求时，告诉浏览器资源的最后修改时间。

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142249541-789089587.png)

##### If-Modified-Since

1. 再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回资源的最后修改时间。

2. 服务器收到请求后发现请求头中有 `If-Modified-Since`，则与被请求资源的最后修改时间进行对比。
3. 若资源的最后修改时间大于 `If-Modified-Since`，说明资源有被修改过，则响应整片资源内容，返回状态码 200 。
4. 若资源的最后修改时间小于等于 `If-Modified-Since`，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用缓存数据。

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142307166-135607673.png)

#### Etag / If-None-Match

**优先级高于 `Last-Modified / If-Modified-Since`**

##### Etag

服务器响应请求后，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142054182-1766818273.png)

##### If-None-Match

1. 再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识
2. 服务器收到后发现请求头中有 `If-None-Match`，则与被请求资源的唯一标识进行比对
3. 不同，说明资源有被改动过，则响应整片资源内容，返回状态码 200 。
4. 相同，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用缓存数据

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142115479-1921175758.png)

### 总结

**对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，不在时间内，执行比较缓存策略。**

**对于比较缓存，将缓存信息中的 `Last-Modified` 和 `Etag` 通过 请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。**

## 浏览器输入网址到页面渲染的过程

### 输入网址后的流程

1. DNS 域名解析（查找 `ip` ）
2. 三次握手
3. 建立 `TCP` 链接，发送 `http` 请求
4. 服务器响应 `http` 请求，浏览器得到 `html` 代码
5. 浏览器解析 `html` 代码
6. 浏览器对页面进行渲染并呈现给用户

### 域名解析的流程

- 先从浏览器缓存中查找是否有该域名
- 浏览器缓存中没有则从系统缓存中找（本地HOST文件）
- 系统缓存中没有则从路由缓存中查找
- 路由缓存中没有则从本地DNS服务器查找（一般为电信、移动等网络接入服务器商）
- 本地DNS服务器没有则从其他DNS服务器查找（顺序为：根域名服务器，一级域名服务器，二级域名服务器，三级域名服务器）

### 页面渲染

![WebKit渲染过程](https://segmentfault.com/img/bVCZ1H?w=694&h=340)

- 通过 `html` 解析器把 `HTML ` 文件解析成 `DOM` 树
- 通过 `css` 解析器把 `CSS` 文件解析成 `Css Rule Tree`
- 将 `DOM` 树 和 `CSS Rule Tree` 结合生成渲染树，这个过程称为 `Flow` 或者 `Layout`
- 根据渲染树计算每个节点的信息，并开始绘制页面，这个过程称为 `Paint`

遇到 `<script>` 时，会执行并阻塞渲染(为什么会阻塞渲染？因为 `<script>` 里面是 `js` ，`js` 有权利改变 `DOM` 结构)

> DOM tree 只是一个树形结构，他上面并没有每个节点的样式，渲染树和DOM树 在结构上是一样的，但是每个节点都有对应的样式

## 回流 重绘

元素的布局、显隐性、大小、位置等发生变化而需要重新构建，称为**回流**。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构建这部分树，完成回流后，浏览器会重新绘制受到影响的这部分，引发重绘。

颜色、字体等外观风格的变化，不影响布局的，称为**重绘**。

回流必将引起重绘，而重绘不一定引起回流。

### 如何减少重绘与回流

**css**

1. 使用 `transform` 替代 `top` 
2. 使用 `visibility` 替代 `display: none`，因为前者只会引起重绘，后者会引发回流
3. 避免使用 `table` 布局，可能很小的一个改动就会造成整个 `table` 的重新布局
4. 尽可能在 `DOM` 树的最末端改变 `class` ，回流是不可避免的，但是可以限制回流的范围，使其影响尽可能少的节点
5. 避免设置多层内联样式， `CSS` 选择符从右往左匹配查找，避免节点层级过多
6. 避免使用 `css` 表达式，可能会引发回流
7. 使用 `css3` 硬件加速，可以让 `transform`、`opacity` 、`filters` 这些动画不会引起回流重绘。但是对于动画的其它属性，比如 `background-color` 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

**javascript**

1. 避免频繁操作样式，最好一次性重写 `style` 属性，或者将样式列表定义为 `class` 并一次性更改 `class` 属性。

2. 避免频繁操作 `DOM`，创建一个 `documentFragment` ，在它上面应用所有 `DOM` 操作，最后再把它添加到文档中。

3. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。

## CSS 选择器从右往左的匹配规则

[CSS选择器从右往左的匹配规则](https://www.cnblogs.com/zhaodongyu/p/3341080.html)

## CSS 表达式

[什么是css表达式？](https://www.html.cn/qa/css3/12398.html)

## JS动画和CSS3动画的差异

[JS动画和CSS3动画的区别](https://www.cnblogs.com/mwxz/p/13206226.html)

### JS 动画（逐帧动画）

`js` 动画是逐帧动画，是在时间帧上逐帧绘制帧内容，由于是一帧一帧的，所以他的可操作性很高，几乎可以完成任何想要的动画形式。但是由于逐帧动画的帧序列内容不一样，会增加制作负担，且资源占有比较大。

**优点：**

1. `JS` 动画的控制能力很强，可以在动画播放过程中进行开始、暂停、回放、终止等操作；
2. 动画效果比 `CSS3` 动画丰富，比如曲线运动、冲击闪烁、视差滚动等效果，只有 `JS` 动画才能完成
3. `CSS3` 有兼容性问题，而 `JS` 大多数没有兼容性问题

**缺点：**

1. `JS` 在浏览器的主线程中运行，而主线程中还有其他需要运行的 `JS` 脚本、样式计算、布局、绘制任务等，对其干扰导致线程可能出现阻塞，从而造成丢帧的情况；
2. 代码的复杂度高于 `CSS` 动画

### CSS3动画（补间动画）

`CSS` 制作方法简单方便，只需确定第一帧和最后一帧的关键位置即可。两个关键帧之间的内容由 `flash` 自动生成，不需要人为处理。当然也可以多次添加关键帧的位置。

**优点：**

1. 浏览器可以对动画进行优化
    - 浏览器使用与 `requestAnimationFrame` 类似的机制，`requestAnimationFrame` 比起 `setTimeout` 、`setInterval` 设置动画的优势是 ：
    - 1. `requestAnimationFrame` 会把每一帧中的所有 `DOM` 操作集中起来，在一次重绘或者回流中就完成，并且重回或者回流的时间间隔紧紧跟随浏览器的刷新频率，这个频率为每秒60帧
    - 2. 在隐藏或者不可见的元素中，`requestAnimationFrame` 不会进行重回或者回流，这当然意味着更少的 `cpu`、`gpu` 和内存的使用量
2. 可以使用硬件加速（通过 `GPU` 来提高动画性能）
3. `css3`不占用 `JS` 主线程

**缺点：**

1. 运行过程控制较弱，无法添加事件。
2. 想用 `CSS` 实现稍复杂一点的动画，代码会变得十分冗长

## requestAnimationFrame

[深入理解定时器系列第一篇——理解setTimeout和setInterval](https://www.cnblogs.com/xiaohuochai/p/5773183.html)

[深入理解定时器系列第二篇——被誉为神器的requestAnimationFrame](https://www.cnblogs.com/xiaohuochai/p/5777186.html)

## 如果需要手写动画，你认为最小的时间间隔是多久？

多数显示器默认频率是 60HZ，即1秒刷新60次，所以理论上最小间隔为 1/60 * 1000 = 16.7 ms。

## 本地存储和cookie区别

### cookie

- 本身用于客户端和服务器的通信，但他有本地存储的功能，于是就被“借用"
- 使用 `document.cookie = xxx` 即可获取和修改
- 主要用途有保存登录信息
- 一般服务器端生成，可设置失效时间，如果在浏览器端生成，默认关闭浏览器后失效

**缺点：**

- 存储量太小，只有 4KB
- 所有的 `http` 请求都带着，会影响获取资源的效率
- API简单，需要封装才能使用

**cookie 的属性**

| 参数   | 描述                                    |
| :----- | :-------------------------------------- |
| name   | 规定cookie的名称                        |
| value  | 规定cookie的值                          |
| expire | 规定cookie的有效期                      |
| path   | 规定cookie的服务器的路径                |
| domain | 规定cookie的域名                        |
| secure | 规定是否通过安全的https链接来传输cookie |

### localStorage 、sessionStorage

- `HTML5` 专门为存储而设计，最大容量 `5M`
- `API` 简单易用，存：`localStorage.xxx = "xxx"` , 取： `localStorage.xxx`
- `sessionStorage` 只要浏览器关了，就清除了，
- `localStorage` 是永久存储

## HttpOnly

如果某一个 `Cookie` 选项被设置成 `HttpOnly = true` 的话，那此 `Cookie` 只能通过服务器端修改，`JS` 是操作不了的

## get post的区别

[GET和POST两种请求的区别](https://www.cnblogs.com/logsharing/p/8448446.html)

[都9102年了，还问GET和POST的区别](https://segmentfault.com/a/1190000018129846)

## DOM 事件

`DOM` 级别一共可以分为4个级别：`DOM` 0级，`DOM` 1级，`DOM` 2级，`DOM` 3级。

`DOM` 事件级别分为3个级别：`DOM` 0级事件处理，`DOM` 2级事件处理，`DOM` 3级事件处理。

> 因为DOM 1级标准中没有定义事件相关的内容，所以没有所谓的DOM 1级事件处理程序。

在 `DOM` 0级事件之前，我们有必要了解下 `HTML` 事件处理程序，也是最早的一种事件处理方式：

```html
<button type="button" onclick="showFn()"></button>

<script>
    function showFn () {
        console.log("hello world");
    }
</script>
```

> 上面的代码，我们通过直接在 `html` 代码里面定义一个 `onclick` 属性触发 `showFn` 这样的事件处理程序最大的缺点就是 `html` 和 `js` 的耦合太强，我们如果修改函数名就必须要修改两个地方，优点是不需要操作 `DOM` 来完成事件的绑定。

### 1. DOM 0级事件处理程序

**DOM 0级处理事件就是将一个函数赋值给一个事件处理属性。**

```html
<button id="btn" type="button"></button>

<script>
	let btn = document.getElementById("btn");
    btn.onclick = function () {
        console.log("hello world");
    };
</script>
```

将一个函数赋值给一个事件处理属性 `onclick` 这样的方式就是 `DOM` 0级处理事件的体现。通过给事件处理属性赋值 `null` 来解绑事件。

> DOM 0级事件处理程序的缺点在于一个处理程序无法同时绑定多个处理函数

### 2. DOM 2级事件处理程序

`DOM` 2级事件处理程序弥补了 `DOM` 0级事件处理程序无法同时绑定多个处理函数的缺点。

```html
<button id="btn" type="button"></button>

<script>
	let btn = document.getElementById("btn");
    function showFn () {
        console.log("hello world");
    }
    btn.addEventListener("click", showFn, false); // true: 捕获阶段触发   false: 冒泡阶段触发
    // btn.removeEventListener("click", showFn, false); // 解绑事件
</script>
```

`DOM` 2级事件定义了 `addEventListener` 和 `removeEventListener` 两个方法，分别用来绑定和解绑事件，方法中包含三个参数，分别是绑定的事件处理的属性名称、处理函数、是否在捕获阶段执行事件处理函数。如果我们还需要添加一个鼠标移入的方法，只需要：

```javascript
btn.addEventListener("mouseover", showFn, false);
```

> 需要注意，IE8以下版本不支持  addEventListener 和 removeEventListener，需要使用 attachEvent 和 detachEvent 实现

### 3. DOM 3级事件处理程序

`DOM` 3级事件在 `DOM` 2级事件的基础上添加了更多的事件类型，全部类型如下：

1. UI 事件，如：load，scroll
2. 焦点事件，如：blur，focus
3. 鼠标事件，如：dbclick，mouseup
4. 滚轮事件，如：mousewheel
5. 文本事件，如：textInput
6. 键盘事件，如：keydown，keypress
7. 合成事件，如：compositionstart
8. 变动事件，如：DOMsubtreeModified

## JS语言的特性

- 运行在客户端浏览器上
- 不用预编译，浏览器直接解析执行代码
- 弱类型语言，较为灵活
- 与操作系统无关，跨平台语言
- 脚本语言，解释性语言

## 同源策略，跨域

[浏览器同源策略及跨域的解决方法](https://juejin.cn/post/6844903681683357710)

跨域解决方案：

1. [CORS](https://juejin.cn/post/6844903681683357710#:~:text=CORS%EF%BC%88Cross-origin%20resource%20sharing%EF%BC%8C%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89)
    - 优点：
        1. CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。
        2. 支持所有类型的 HTTP 请求。
    - 缺点：
        1. 存在兼容性问题，特别是 IE10 以下浏览器。
        2. 第一次发送非简单请求时会多一次请求。
2. [JSONP](https://juejin.cn/post/6844903681683357710#:~:text=%E5%A4%9A%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E3%80%82-,JSONP%20%E8%B7%A8%E5%9F%9F,-%E7%94%B1%E4%BA%8E%20script%20%E6%A0%87%E7%AD%BE)
    - 优点：
        1. 使用简便，没有兼容性问题。
    - 缺点：
        1. 只支持 GET 请求
        2. 由于是从其他域中加载代码执行，因此如果其他域不安全，和有可能在响应中夹带一些恶意代码。
        3. 要确定 JSONP 请求是否失败并不容易。
3. [图像 PING 跨域](https://juejin.cn/post/6844903681683357710#:~:text=%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E3%80%82-,%E5%9B%BE%E5%83%8F%20Ping%20%E8%B7%A8%E5%9F%9F,-%E7%94%B1%E4%BA%8E%20img%20%E6%A0%87%E7%AD%BE)
    - 优点：
        1. 用于实现跟踪用户点击页面或者动态广告曝光次数有较大的优势。
    - 缺点：
        1. 只支持 GET 请求。
        2. 只能浏览器与服务器单向通信，因为浏览器不能访问服务器的响应文本
4. [服务器代理](https://juejin.cn/post/6844903681683357710#:~:text=%E7%9A%84%E5%93%8D%E5%BA%94%E6%96%87%E6%9C%AC%E3%80%82-,%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86,-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89)：浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。服务器代理是万能的。
5. [document.domain 跨域](https://juejin.cn/post/6844903681683357710#:~:text=%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84%E3%80%82-,document.domain%20%E8%B7%A8%E5%9F%9F,-%E5%AF%B9%E4%BA%8E%E4%B8%BB%E5%9F%9F)：对于主域名相同，而子域名不同的情况，可以使用 `document.domain` 来跨域。这种方式非常适用于 `iframe` 跨域的情况。
6. [window.name 跨域](https://juejin.cn/post/6844903681683357710#:~:text=%E5%92%8C%E5%AF%B9%E8%B1%A1%E4%BA%86%E3%80%82-,window.name%20%E8%B7%A8%E5%9F%9F,-window%20%E5%AF%B9%E8%B1%A1%E6%9C%89)：`window` 对象有个 `name` 属性，该属性有个特征：即在一个窗口的生命周期内，窗口载入的所有的页面都是共享一个 `window.name` 的，每个页面对 `window.name` 都有读写的权限，`window.name` 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
7. [location.hash 跨域](https://juejin.cn/post/6844903681683357710#:~:text=%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81-,location.hash%20%E8%B7%A8%E5%9F%9F,-location.hash%20%E6%96%B9%E5%BC%8F)：子框架修改父框架 `src` 的 `hash` 值，通过这个属性进行传递数据，且更改 `hash` 值，页面不会刷新。但是传递的数据的字节数是有限的。
8. [postMessage 跨域](https://juejin.cn/post/6844903681683357710#:~:text=window.postMessage(message%EF%BC%8CtargetOrigin)%20%E6%96%B9%E6%B3%95%E6%98%AF%20HTML5%20%E6%96%B0%E5%BC%95%E8%BF%9B%E7%9A%84%E7%89%B9%E6%80%A7)：该方法是 `HTML5` 新引进的特性，可以使用它来向其它的 `window` 对象发送消息，无论这个 `window` 对象是属于同源或不同源

## HTTP协议和HTTPS协议

1. `http` 是超文本传输协议，信息是明文传输，`https` 则是具有安全性的 `ssl` 加密传输协议。

2. `http` 和 `https` 使用的是完全不同的连接方式，用的端口也不一样，前者是 `80`，后者是 `443`。

3. `http` 的连接很简单，是无状态的；`HTTPS` 协议是由 `SSL+HTTP` 协议构建的可进行加密传输、身份认证的网络协议，比 `http` 协议安全。

## 常见 http 状态码

| 状态码 | 描述                                                         |
| :----: | ------------------------------------------------------------ |
|  100   | **告诉客户端继续发送请求，服务器返回此状态表示已收到第一部分请求，正在等待其余部分** |
|  101   | 客户端要求服务器切换协议，服务器已确认并准备切换             |
|  200   | **服务器已成功处理了请求**                                   |
|  201   | 请求成功并且服务器创建了新的资源                             |
|  202   | **服务器已接受请求，但尚未处理**                             |
|  203   | 服务器已成功处理了请求，但返回的信息可能来自另一个源         |
|  204   | **服务器成功处理了请求，但没有返回任何内容**                 |
|  206   | 服务器成功处理了部分GET请求                                  |
|  301   | **（永久重定向）请求的网页以永久移动到新位置**               |
|  302   | **（临时重定向）临时从旧地址A跳转到地址B**                   |
|  304   | **资源已找到，但是不满足条件，所以不把资源返回给客户端。常用于协商缓存** |
|  400   | **请求报文内有语法错误**                                     |
|  401   | **请求要求身份验证**                                         |
|  403   | **请求资源的访问被服务器拒绝**                               |
|  404   | **服务器上找不到资源或路径错误**                             |
|  405   | 请求方法未被服务端识别                                       |
|  500   | **服务器端在请求时出错**                                     |
|  502   | 代理服务器或网关从上游服务器中收到无效响应                   |
|  503   | **服务器暂时处于超负载或停机维护，目前无法处理请求**         |

**301和302的区别：**

​		301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的 `Location` 首部中获取（**用户看到的效果就是他输入的地址A瞬间变成了另一个地址B**）——**这是它们的共同点**。
  	他们的不同在于。301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301

**重定向原因：**

1. 网站调整（如改变网页目录结构）；
2. 网页被移到一个新地址；
3. 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。

## 懒加载 预加载

### 懒加载

**懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式**。用户滚动到它们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。

**懒加载实现原理**

首先将页面上的图片的 `src` 属性设为空字符串，而图片的真实路径则设置在 `data-src`属性中， 当页面滚动的时候需要去监听 `scroll` 事件，在 `scroll` 事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 `src` 属性设置为`data-src` 的值，这样就可以实现延迟加载。

### 预加载

资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。**预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源**。

在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。

**实现预加载的几种办法：**

1. 使用 HTML 标签

    ```html
    <img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/>
    ```

2. 使用 Image 对象

    ```javascript
    var image= new Image()
    image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg"
    ```

3. 使用 XMLHttpRequest 对象，虽然存在跨域，但会精细控制与加载过程

4. 使用 PreloadJS 库

**懒加载和预加载的对比：**

两者都是提高页面性能有效的办法，**两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力**。

## 前端安全

### 1. CSRF 跨站请求伪造

攻击者盗用了用户的身份，以该用户的名义进行恶意请求。它能做的事情有很多包括：以该用户的名义发邮件、发信息、盗取账号、购买商品、虚拟货币转账等。总结就是：个人隐私暴露及财产安全问题。

```html
阐述 CSRF 攻击思想：（核心2、3）
1. 浏览并登录信任网站（举例：淘宝）
2. 登录成功后在浏览器产生存储（举例：cookie）
3. 用户在没有登出淘宝的情况下，访问危险网站
4. 危险网站中存在恶意代码，代码为发送一个恶意请求（举例：购买商品、余额转账）
5. 携带刚刚在浏览器产生的信息进行恶意请求
6. 淘宝验证为合法请求（区分不出是否是该用户发送）
7. 达到恶意目标
```

**防御措施**

- 涉及到数据修改操作严格使用 `post` 请求而不是 `get` 请求
- `http`协议中使用 `Referer` 属性来确定请求来源进行过滤（禁止外域）
- 请求地址添加 `token`，使黑客无法伪造请求（推荐）
- `http` 头自定义属性验证（推荐）
- 显示验证方式：添加验证码、密码

### 2. XSS 跨站脚本攻击

攻击者在目标网站植入恶意脚本（`js/html`），用户在浏览器上运行时可以获取用户敏感信息（`cookie/session`）、修改 `web` 页面以欺骗用户、与其他漏洞相结合形成蠕虫等。

**XSS类型**

- 持久型XSS：将脚本植入到服务器上，从而导致每个访问的用户都会执行
- 非持久型XSS：对个体用户某 `url` 的参数进行修改

**防御措施（对用户输入内容和服务器返回内容进行过滤和转译）**

- 现代大部分浏览器都自带 XSS 筛选器，vue / react 等成熟框架也对 XSS 进行一些防护

- 即便如此，我们在开发时也要注意和小心

- 对用户输入内容和服务端返回内容进行过滤和转译

- 重要内容加密传输

- 合理使用get/post等请求方式

- 对于URL携带参数谨慎使用

- 我们无法做到彻底阻止，但是能增加黑客攻击成本，当成本与利益不符时自然会降低风险

### 3. CDN劫持

出于性能考虑，前端应用通常会把一些静态资源存放到 `CDN` 上面，例如 `js` 脚本和 `style` 文件。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全问题。如果攻击者劫持了 `CDN`，或者对 `CDN`中的资源进行了污染，攻击者可以肆意篡改我们的前端页面，对用户实施攻击。

现在的 `CDN`以支持 `SRI` 为荣，`script` 和 `link` 标签有了新的属性 `integrity` ，这个属性是为了防止校验完整性来判断是否被篡改。他通过 **验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改**

使用 `SRI` 需要两个条件：一是要保证 **资源同域** 或开启跨域，二是在 `<script>` 中 **提供签名** 以供校验。

```javascript
<script
	crossorigin="anonymous"
	integrity="sha384-xBuQ/xzmlsLoHpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHiW2I5f"
	src="http://lib.baomitu.com/jquery/3.2.1/jquery.min.js"
```

> `integrity` 属性分为两个部分，第一个部分是指定哈希值的生成算法（例如：sha384），第二个部分是经过编码的实际哈希值，两者之间用一个短横（-）来分隔。

这个属性存在兼容性问题

![img](https://pic2.zhimg.com/80/v2-b261b0bffcdf1d30d10c84bdccbe78a9_720w.jpg)

## SEO

**什么是SEO：**

搜索引擎优化（`Search Engine Optimization`），简称 `SEO`，简单的说，为了让你的网站在搜索引擎的结果中排名更靠前（当然充钱也行）

**前端如何进行SEO：**

1. `<head>`标签放网页的标题，各个页面不同。
2. `<meta keywords>`列举出几个重要的关键词。
3. `<meta description>`网页内容的高度概括。
4. `html` 语义化。例如我们要做一个导航，如果使用`div`+`span`，毫无语义化，推荐使用 `ul+li`标记。再通过合适的 `css` 样式来实现效果。
5. `<a>`标记要加上说明（`title`属性），对于指向外部网站的链接要使用`rel="nofollow"`属性告诉爬虫不要去爬其他的页面。
6. `<h1>`正文标题要使用`<h1>`标记，副标题要使用`<h2>`。可以使用CSS样式进行显式风格的设置。切记：*不重要的地方不要随便使用`<h1>`标记*。
7. `<table>`标记的优化。使用`<caption>`标记为表格指定标题。
8. 强调网页中的重要内容应该使用`<strong>`标记，避免使用`<b>`标记（对搜索引擎不友好）。`<em>`的权重仅次于`<strong>`。如果仅仅使显示的效果发生变化就使用`<b>`标记和`<i>`标记。
9. 对于暂时不需要显示的元素应该使用`z-index`属性而不是`display:none;`这样的代码，因为Spider会过滤`display`属性为`none`的内容。

## use strict

设立"严格模式"的目的，主要有以下几个：

- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的Javascript做好铺垫。

## js异步加载的方式

[网页性能优化之异步加载js文件](https://juejin.cn/post/6844903696875126798)

正常的网页加载`js`脚本流程如下：

1. 浏览器一边下载`html`网页，一边开始解析；
2. 解析过程中，浏览器发现`<script>`元素，就暂停解析，把网页渲染的控制权转交给`JavaScript`引擎；
3. 如果`<script>`元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码；
4. `JavaScript`引擎执行完毕，控制权交还给渲染引擎，恢复解析`html`网页。

> 加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 `JavaScript` 代码可以修改 `DOM`，所以必须把控制权让给它，否则会导致复杂的线程竞塞的问题。

> 上面所说的，就是我们平时最常见到的，将`<script>`标签放到`<head>`中的做法，这样的加载方式叫做**同步加载**，或者叫阻塞加载，因为在加载`js`脚本文件时，会阻塞浏览器解析`HTML`文档，等到下载并执行完毕之后，才会接着解析`HTML`文档。如果加载时间过长（比如下载时间太长），就会造成浏览器“假死”，页面一片空白。而且，放在`<head>`中同步加载的`js`文件中不能对`DOM`进行操作，否则会产生错误，因为这个时候`HTML`还没有进行解析，`DOM`还没有生成。由此看来，同步加载带来的体验往往并不好。

**下面是几种异步加载`js`的方式：**

**1. 将 `<script>` 标签放到 `<body>` 底部**

将 `<script>` 放到 `<body>` 底部，解决上上面说到的几个问题，一是不会造成页面解析的阻塞，就算加载时间过长用户也可以看到页面而不是一片空白，而且这时候可以在脚本中操作 `DOM`。

> 严格来讲，这种方式并不算是异步加载，但是这也是常见的通过改变 `js` 加载方式来提升页面性能的一种方式

**2. `defer` 属性**

通过给 `<script>` 标签设置 `defer` 属性，将脚本文件设置为延迟加载，当浏览器遇到带有 `defer` 属性的 `<script>` 标签时，会再开启一个线程去下载 `js` 文件，同时继续解析 `html` 文档，等 `html` 全部解析完毕 `dom` 加载完层之后，再去执行加载好的 `js` 文件。

这种方法只适用于引用外部 `js` 文件的 `<script>` 标签，可以保证多个 `js` 文件的执行顺序就是他们在页面中出现的顺序。

**3. `async` 属性**

`async` 属性和 `defer` 属性类似，也是会开启一个线程去下载 `js` 文件，但和 `defer` 不同的是，`async` 会在下载完成后立即执行，而不会等 `DOM` 加载完成之后再执行，所以还是有可能会造成阻塞。

`async` 也只适用于外部 `js` 文件，对于多个带有 `async` 的 `js` 文件，他不能像 `defer` 那样保证按顺序执行，`async` 方式是哪个 `js` 文件先下载完就先执行。

> 如果要保证脚本之间的执行顺序，应当使用 `defer`，不需要保证执行顺序的话用 `async`，如果同时使用的话，`defer`会失效。

![preview](https://segmentfault.com/img/bVWhRl?w=801&h=814/view)



**4.动态创建 `<script>` 标签**

```javascript
(function(){
    var scriptEle = document.createElement("script");
    scriptEle.type = "text/javasctipt";
    scriptEle.async = true;
    scriptEle.src = "http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js";
    var x = document.getElementsByTagName("head")[0];
    x.insertBefore(scriptEle, x.firstChild); 
})();
```

## 事件循环、宏任务 微任务

[JavaScript中的Event Loop（事件循环）机制](https://segmentfault.com/a/1190000022805523)

## 如果一段 JS 执行时间非常长，怎么分析

[Chrome Performance 页面性能分析指南](https://juejin.cn/post/6850418121548365831)

## axios 的拦截器

[axios拦截器](https://juejin.cn/post/6844903906191867912)

## npm安装机制

[npm 模块安装机制简介](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22)

1. 发出 `npm install` 命令
2. `npm` 向 `registry` 查询模块压缩包的网址
3. 下载压缩包，存放在根目录的 `~/.npm` 目录里
4. 解压压缩包到当前项目的 `node_modules` 目录

一个模块安装以后，本地其实保存了两份。一份是 `~/.npm` 目录下的压缩包，另一份是 `node_modules` 目录下解压后的代码。

但是，运行 `npm install` 的时候，只会检查 `node_modules`目录，而不会检查`~/.npm`目录。

如果一个模块在 `~/.npm` 下有压缩包，但是没有安装在 `node_modules` 目录中，`npm` 依然会从远程仓库下载一次新的压缩包。

## 有以下三个判断数组的方法，介绍他们的区别和优劣。Object.prototype.toString.call()、instanceof、Array.isArray()

[有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/23)

## 模块化发展的历程

[js模块化发展历程 总结](https://juejin.cn/post/6844903986206605320)

## 为什么 VUE 3 采用了 Proxy ，抛弃了 Object.defineProperty

[参考](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90)

1. `Object.defineProperty` 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；

    > `Object.defineProperty` 本身是可以监控到数组下标的变化的，但是在 `Vue` 中，从性能/体验的性价比考虑，尤大大就弃用了这个特性。

2. `Object.defineProperty` 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。`Proxy` 可以劫持整个对象，并返回一个新的对象。

3. `Proxy` 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。

## TCP 和 UDP的区别

1. TCP 是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。
2. TCP 提供可靠的服务，通过TCP链接传送的数据，无差错，不丢失，且按序到达。UDP是尽最大努力交付，不保证可靠交付。因为TCP可靠，面向连接，不会丢失数据因此适合大数据量的交换
3. TCP是面向字节流，UDP是面向报文
4. TCP只能是1对1，UDP支持1对1,1对多
5. TCP首部较大为20字节，UDP只有8字节
6. TCP是面向连接的可靠性传输，UDP是不可靠的

## 响应式布局的常用解决方案对比

[响应式布局的常用解决方案对比](https://github.com/forthealllight/blog/issues/13)

1. 媒体查询。

    ```css
    @media screen and (max-width: 960px){
        body{
          background-color:#FF6699
        }
    }
    ```

    缺点：如果浏览器大小改变时，需要改变的样式太多，代码会变得很繁琐

2. 百分比。

    缺点：

    1. 计算困难，如果要定义一个元素的宽度和高度，按照设计稿，要换算成百分比单位。
    2. 百分比相对于父元素的属性不是唯一的，比如 `width` 和 `height` 相对于父元素的 `width` 和 `height`；而 `margin` 、`padding` 不管垂直还是水平方向都相对于父元素的宽度；`border-radius` 则是相对于元素自身等等。
    
3. rem。只相对于浏览器根元素（html元素）的 `font-size` 。当页面的大小发生改变时，只需要改变根元素的 `font-size` 的值，那么以 `rem` 为固定单位的元素的大小也会发生变化。

    缺点：

    1. 需要使用 `JS` 来动态控制根元素 `font-size` 的大小。
    
4. vw / vh。`vw` 相对于视图窗口宽度，`vh` 相对于视图窗口高度。视窗宽度等于 `100vw` ，视窗高度等于 `100vh` 。`1vw` 等于视图宽度的百分之一，`1vh` 等于视图高度的百分之一。

    缺点：

    1. 兼容性。`opera` 不支持 `vw` 单位。    

## http 常用请求头

[常用的http请求头以及响应头详解](https://www.pianshen.com/article/33571218055/)

## HTTP 的15个常见知识点复习

[HTTP 的15个常见知识点复习](https://juejin.cn/post/6844903872935247886#heading-23)

## flutter有了解过吗？为什么说它的性能可以媲美原生？它有什么缺点吗？

## 浏览器进程

## JavasScript 内存机制

`Js` 内存空间分为 **栈(stack)**、**堆(heap)**、**池**。其中

- **栈**存放变量，基本数据类型与指向复杂数据类型的引用指针。
- **堆**存放复杂数据类型。
- **池**存放常量。

### 基础数据类型与栈内存

`JS` 的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中(闭包除外)，由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值。遵循先进后出、后进先出的原则。`Number`、`String`、`Null`、`Undefined`、`Boolean`。

### 引用数据类型与堆内存

引用数据类型的值是保存在堆内存中的对象。JS不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。这里的引用，我们可以粗浅地理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。

```javascript
var a1 = 0; // 栈 
var a2 = 'this is string'; // 栈
var a3 = null; // 栈 
var b = { m: 20 }; // 变量b存在于栈中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于栈中，[1, 2, 3] 作为对象存在于堆内存中
```

| 变量名 | 具体值         |
| ------ | -------------- |
| c      | 0x0012ff7d     |
| b      | 0x0012ff7c     |
| a3     | null           |
| a2     | this is string |
| a1     | 0              |

```javascript
// 堆内存空间
[1, 2, 3]
{m: 20}
```

**因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。**

```javascript
// demo01.js
var a = 20;
var b = a;
b = 30;
// 这时a的值是多少

// demo02.js
var m = { a: 10, b: 20 };
var n = m;
n.a = 15;
// 这时m.a的值是多少 
```

在 `demo1.ja` 中，在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值，`a` 和 `b` 已经是相互独立互不影响的值了。

复制前：

| 栈内存空间 | 值   |
| ---------- | ---- |
| a          | 20   |

复制后：

| 栈内存空间 | 值   |
| ---------- | ---- |
| b          | 20   |
| a          | 20   |

b 值修改后：

| 栈内存空间 | 值   |
| ---------- | ---- |
| b          | 30   |
| a          | 20   |

在 `demo2.js` 中，引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在堆内存中访问到的具体对象实际上是同一个。

复制前：

| 栈内存空间 | 值         |
| ---------- | ---------- |
| m          | 0x0012ff7d |

| 堆内存空间     | 堆内存地址 |
| -------------- | ---------- |
| {a: 10, b: 20} | 0x0012ff7d |

复制后：

| 栈内存空间 | 值         |
| ---------- | ---------- |
| m          | 0x0012ff7d |
| n          | 0x0012ff7d |

| 堆内存空间     | 堆内存地址 |
| -------------- | ---------- |
| {a: 10, b: 20} | 0x0012ff7d |

修改 `n.a = 15` 后：

| 栈内存空间 | 值         |
| ---------- | ---------- |
| m          | 0x0012ff7d |
| n          | 0x0012ff7d |

| 堆内存空间     | 堆内存地址 |
| -------------- | ---------- |
| {a: 15, b: 20} | 0x0012ff7d |

### 生命周期

JS 环境中分配的内存一般有如下生命周期：

1. 内存分配：申明变量、函数、对象时，系统会自动为他们分配内存。
2. 内存使用：读写内存，也就是使用变量、函数等。
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存。

### 垃圾回收机制

JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。 

以全局变量和局部变量来说，函数中的局部变量在函数执行结束后这些变量已经不再被需要，所以垃圾回收器会识别并释放它们。而对于全局变量，垃圾回收器很难判断这些变量什么时候才不被需要，所以尽量少使用全局变量。

那么垃圾回收器是如何检测变量是否需要的呢，大体上分为两种检测手段，**引用计数**与**标记清除**。

**1.引用计数**

引用计数的判断原理很简单，就是看一份数据是否还有指向它的引用，如果没有任何对象再指向它，那么垃圾回收器就会回收，举个例子：

```javascript
// 创建一个对象person，他有两个指向属性age和name的引用
var person = {
    age: 12,
    name: 'aaaa'
};

person.name = null; // 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收

var p = person; 
person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收

p = null;           //原person对象已经没有引用，很快会被回收
```

由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。

```javascript
function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1; 

    return "Cycle reference!"
}

cycle();
```

上面我们申明了一个cycle方程，其中包含两个相互引用的对象。在调用函数结束后，对象o1和o2实际上已离开函数范围，因此不再需要了。但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了

**2. 标记清除**

现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。

标记清除算法将**“不再使用的对象”**定义为**“无法达到的对象”**。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

当一个对象零引用时，我们从根部一定无法到达；但反过来，从根部无法到达的不一定是严格意义上的零引用，比如循环引用，所以标记清除要更优于引用计数。

## JS 垃圾回收机制

[「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214#heading-5)
