## web 性能优化

1. 资源压缩合并，减少`HTTP`请求和文件下载时的体积
2. 非核心代码异步加载 
3. 利用浏览器缓存 
4. 使用 `CDN`
5. 预解析 `DNS`

## CDN原理

由于用户访问源站业务有性能瓶颈，通过cdn技术把源站的内容缓存到多个节点。用户向源站域名发起请求时，请求会被调度至最接近用户的服务节点，直接由服务节点直接快速响应，有效降低用户访问延迟，提升可用性。

## 缓存

[彻底弄懂HTTP缓存机制及原理](https://www.cnblogs.com/chenqf/p/6386163.html)

为方便理解，我们认为**浏览器存在一个缓存数据库**,用于存储缓存信息。

在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。

![第一次请求数据](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141639213-1923993391.png)

`HTTP`缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我们将其分为两大类：**强制缓存、对比缓存**。

**强制缓存请求数据的流程**

![强制缓存](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210135521072-1812985836.png)

**对比缓存请求数据的流程**

![对比缓存](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141716838-764535017.png)

根据上图可以看到，**强制缓存**如果生效，不需要再和服务期发生交互，而**对比缓存**不管是否生效，都需要和服务器发生交互。

两种缓存规则可以同时存在，**强制缓存**优先级高于**对比缓存**。也就是说，当执行**强制缓存**的规则时，如果缓存生效，直接使用缓存，不再执行**对比缓存**规则。

### 强制缓存

在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是**如何判断缓存数据是否失效呢？**

我们知道，在没有缓存数据时，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，**缓存规则信息包含在响应header中**。

对于强制缓存来说，响应 `header`中会有两个字段来标明失效规则（**Expires/Cache-Control**）。

#### Expires

`Expires` 的值为服务器返回的到期时间。即下一次请求时，请求时间小于服务端返回的到期时间，则直接使用缓存数据。

> 不过Expires是 HTTP 1.0 的东西，现在浏览器均默认使用 HTTP 1.1 ，所以它的作用基本忽略。
>
> 还有一个问题，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差，所以 HTTP 1.1 使用 Cache-Control 替代

#### Cache-Control

`Cache-Control` 是最重要的规则。常见的取值有 `private、public、no-cache、max-age、no-store`,默认为 `privare`。

| 值          | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| private     | 客户端可以缓存                                               |
| public      | 客户端和代理服务器都可以缓存（前端的同学，可以认为public和private是一样的） |
| max-age=xxx | 缓存的内容将在xxx秒后失效                                    |
| no-cache    | 需要使用对比缓存来验证缓存数据                               |
| no-store    | 所有内容都不会缓存，强制缓存、对比缓存都不会触发             |

举个栗子

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141836104-1513192908.png)

图中的 `Cache-Control`仅指定了 `max-age`，所以默认为 `private`，缓存时间为31536000秒。

### 对比缓存

顾名思义，需要进行比较判断是否可以使用缓存。

浏览器**第一次请求数据时**，服务器会**将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库**。

再次请求时，客户端**将备份的缓存标识发送给服务器**，**服务器根据缓存标识进行判断**，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

**对于对比缓存来说，缓存标识的传递是我们着重需要理解的**，它在请求header和响应header间进行传递，
一共分为两种标识传递：

#### Last-Modified / If-Modified-Since

##### Last-Modified

服务器在响应请求时，告诉浏览器资源的最后修改时间。

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142249541-789089587.png)

##### If-Modified-Since

1. 再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。

2. 服务器收到请求后发现请求头中有 `If-Modified-Since`，则与被请求资源的最后修改时间进行对比。
3. 若资源的最后修改时间大于 `If-Modified-Since`，说明资源又被修改过，则响应整片资源内容，返回状态码 200 。
4. 若资源的最后修改时间小于等于 `If-Modified-Since`，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用缓存数据。

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142307166-135607673.png)

#### Etag / If-None-Match

**优先级高于 `Last-Modified / If-Modified-Since`**

##### Etag

服务器响应请求后，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142054182-1766818273.png)

##### If-None-Match

1. 再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识
2. 服务器收到后发现请求头中有 `If-None-Match`，则与被请求资源的唯一标识进行比对
3. 不同，说明资源又被改动过，则响应整片资源内容，返回状态码 200 。
4. 相同，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用缓存数据

![1](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142115479-1921175758.png)

### 总结

**对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，不在时间内，执行比较缓存策略。**

**对于比较缓存，将缓存信息中的 `Last-Modified`和 `Etag`通过 请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。**

## 浏览器输入网址到页面渲染的过程

### 输入网址后的流程

1. DNS 域名解析（查找ip）
2. 三次握手
3. 建立`TCP` 链接，发送 `http`请求
4. 服务器响应 `http` 请求，浏览器得到 `html` 代码
5. 浏览器解析 `html` 代码
6. 浏览器对页面进行渲染并呈现给用户

### 域名解析的流程

- 先从浏览器缓存中查找是否有该域名
- 浏览器缓存中没有则从系统缓存中找（本地HOST文件）
- 系统缓存中没有则从路由缓存中查找
- 路由缓存中没有则从本地DNS服务器查找（一般为电信、移动等网络接入服务器商）
- 本地DNS服务器没有则从其他DNS服务器查找（顺序为：根域名服务器，一级域名服务器，二级域名服务器，三级域名服务器）

### 页面渲染

![WebKit渲染过程](https://segmentfault.com/img/bVCZ1H?w=694&h=340)

- 通过`html`解析器把 `HTML`文件解析成`DOM`树
- 通过`css`解析器把`CSS`文件解析成 `Css Rule Tree`
- 将`DOM`树 和 `CSS Rule Tree` 结合生成渲染树，这个过程称为 `Flow` 或者 `Layout`
- 根据渲染树计算每个节点的信息，并开始绘制页面，这个过程称为 `Paint`

遇到 `<script>` 时，会执行并阻塞渲染(为什么会阻塞渲染？因为`<script>`里面是`js`，`js` 有权利改变`DOM` 结构)

> DOM tree 只是一个树形结构，他上面并没有每个节点的样式，渲染树和DOM树 在结构上是一样的，但是每个节点都有对应的样式

## 回流 重绘

元素的布局、显隐性、大小、位置等发生变化而需要重新构建，称为**回流**。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构建这部分树，完成回流后，浏览器会重新绘制受到影响的这部分，引发重绘。

颜色、字体等外观风格的变化，不影响布局的，称为**重绘**。

回流必将引起重绘，而重绘不一定引起回流。

### 如何减少重绘与回流

**css**

1. 使用 `transform` 替代 `top` 
2. 使用 `visibility` 替代 `display: none`，因为前者只会引起重绘，后者会引发回流
3. 避免使用 `table` 布局，可能很小的一个改动就会造成整个 `table` 的重新布局
4. 尽可能在 `DOM` 树的最末端改变 `class` ，回流是不可避免的，但是可以限制回流的范围，使其影响尽可能少的节点
5. 避免设置多层内联样式， `CSS` 选择符从右往左匹配查找，避免节点层级过多
6. 避免使用 `css` 表达式，可能会引发回流
7. 使用 `css3` 硬件加速，可以让 `transform`、`opacity` 、`filters` 这些动画不会引起回流重绘。但是对于动画的其它属性，比如 `background-color` 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

**javascript**

1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为`class`并一次性更改`class`属性。

2. 避免频繁操作 `DOM`，创建一个`documentFragment`，在它上面应用所有`DOM`操作，最后再把它添加到文档中。

3. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。

## CSS 选择器从右往左的匹配规则

[CSS选择器从右往左的匹配规则](https://www.cnblogs.com/zhaodongyu/p/3341080.html)

## CSS 表达式

[什么是css表达式？](https://www.html.cn/qa/css3/12398.html)

## JS动画和CSS3动画的差异

[JS动画和CSS3动画的区别](https://www.cnblogs.com/mwxz/p/13206226.html)

### JS 动画

**优点：**

1. JS动画的控制能力很强，可以在动画播放过程中进行开始、暂停、回放、终止等操作；
2. 动画效果比CSS3动画丰富，比如曲线运动、冲击闪烁、视差滚动等效果，只有JS动画才能完成
3. CSS3有兼容性问题，而JS大多数没有兼容性问题

**缺点：**

1. JS 在浏览器的主线程中运行中运行，而主线程中还有其他需要运行的JS脚本、样式计算、布局、绘制任务等，对其干扰导致线程可能出现阻塞，从而造成丢帧的情况；
2. 代码的复杂度高于CSS动画

### CSS3动画

**优点：**

1. 浏览器可以对动画进行优化
    - 浏览器使用与 `requestAnimationFrame` 类似的机制，`requestAnimationFrame` 比起 `setTimeout` 、`setInterval` 设置动画的优势是 ：
    - 1. `requestAnimationFrame` 会把每一帧中的所有 `DOM` 操作集中起来，在一次重绘或者回流中就完成，并且重回或者回流的时间间隔紧紧跟随浏览器的刷新频率，这个频率为每秒60帧
    - 2. 在隐藏或者不可见的元素中，`requestAnimationFrame` 不会进行重回或者回流，这当然意味着更少的 `cpu`、`gpu` 和内存的使用量
2. 强制使用硬件加速（通过GPU来提高动画性能）

**缺点：**

1. 运行过程控制较弱，无法添加事件。
2. 想用CSS实现稍复杂一点的动画，代码会变得十分冗长

## requestAnimationFrame

[深入理解定时器系列第一篇——理解setTimeout和setInterval](https://www.cnblogs.com/xiaohuochai/p/5773183.html)

[深入理解定时器系列第二篇——被誉为神器的requestAnimationFrame](https://www.cnblogs.com/xiaohuochai/p/5777186.html)

## 如果需要手写动画，你认为最小的时间间隔是多久？

多数显示器默认频率是 60HZ，即1秒刷新60次，所以理论上最小间隔为 1/60 * 1000 = 16.7 ms。

## 本地存储和cookie区别

### cookie

- 本身用于客户端和服务器的通信，但他有本地存储的功能，于是就被“借用"
- 使用 `document.cookie = xxx` 即可获取和修改
- 主要用途有保存登录信息
- 一般服务器端生成，可设置失效时间，如果在浏览器端生成，默认关闭浏览器后失效

**缺点：**

- 存储量太小，只有 4KB
- 所有的 `http` 请求都带着，会影响获取资源的效率
- API简单，需要封装才能使用

**cookie 的属性**

| 参数   | 描述                                    |
| :----- | :-------------------------------------- |
| name   | 规定cookie的名称                        |
| value  | 规定cookie的值                          |
| expire | 规定cookie的有效期                      |
| path   | 规定cookie的服务器的路径                |
| domain | 规定cookie的域名                        |
| secure | 规定是否通过安全的https链接来传输cookie |

### localStorage 、sessionStorage

- HTML5 专门为存储而设计，最大容量5M
- API简单易用，存：`localStorage.xxx = "xxx"` , 取： `localStorage.xxx`
- `sessionStorage` 只要浏览器关了，就清除了，
- `localStorage` 是永久存储

## HttpOnly

如果某一个 `Cookie` 选项被设置成 `HttpOnly = true` 的话，那此 `Cookie` 只能通过服务器端修改，`Js` 是操作不了的

## get post的区别

[GET和POST两种请求的区别](https://www.cnblogs.com/logsharing/p/8448446.html)

[都9102年了，还问GET和POST的区别](https://segmentfault.com/a/1190000018129846)

## DOM 事件

`DOM` 级别一共可以分为4个级别：`DOM` 0级，`DOM` 1级，`DOM` 2级，`DOM` 3级。

`DOM` 事件级别分为3个级别：`DOM` 0级事件处理，`DOM` 2级事件处理，`DOM` 3级事件处理。

> 因为DOM 1级标准中没有定义事件相关的内容，所以没有所谓的DOM 1级事件处理程序。

在 `DOM` 0级事件之前，我们有必要了解下 `HTML` 事件处理程序，也是最早的一种事件处理方式：

```html
<button type="button" onclick="showFn()"></button>

<script>
    function showFn () {
        console.log("hello world");
    }
</script>
```

> 上面的代码，我们通过直接在 `html` 代码里面定义一个 `onclick` 属性触发 `showFn` 这样的事件处理程序最大的缺点就是 `html` 和 `js` 的耦合太强，我们如果修改函数名就必须要修改两个地方，优点是不需要操作 `DOM` 来完成事件的绑定。

### 1. DOM 0级事件处理程序

**DOM 0级处理事件就是将一个函数赋值给一个事件处理属性。**

```html
<button id="btn" type="button"></button>

<script>
	let btn = document.getElementById("btn");
    btn.onclick = function () {
        console.log("hello world");
    };
</script>
```

将一个函数赋值给一个事件处理属性 `onclick` 这样的方式就是 `DOM` 0级处理事件的体现。通过给事件处理属性赋值 `null` 来解绑事件。

> DOM 0级事件处理程序的缺点在于一个处理程序无法同时绑定多个处理函数

### 2. DOM 2级事件处理程序

`DOM` 2级事件处理程序弥补了 `DOM` 0级事件处理程序无法同时绑定多个处理函数的缺点。

```html
<button id="btn" type="button"></button>

<script>
	let btn = document.getElementById("btn");
    function showFn () {
        console.log("hello world");
    }
    btn.addEventListener("click", showFn, false); // true: 捕获阶段触发   false: 冒泡阶段触发
    // btn.removeEventListener("click", showFn, false); // 解绑事件
</script>
```

`DOM` 2级事件定义了 `addEventListener` 和 `removeEventListener` 两个方法，分别用来绑定和解绑事件，方法中包含三个参数，分别是绑定的事件处理的属性名称、处理函数、是否在捕获阶段执行事件处理函数。如果我们还需要添加一个鼠标移入的方法，只需要：

```javascript
btn.addEventListener("mouseover", showFn, false);
```

> 需要注意，IE8以下版本不支持  addEventListener 和 removeEventListener，需要使用 attachEvent 和 detachEvent 实现

### 3. DOM 3级事件处理程序

`DOM` 3级事件在 `DOM` 2级事件的基础上添加了更多的事件类型，全部类型如下：

1. UI 事件，如：load，scroll
2. 焦点事件，如：blur，focus
3. 鼠标事件，如：dbclick，mouseup
4. 滚轮事件，如：mousewheel
5. 文本事件，如：textInput
6. 键盘事件，如：keydown，keypress
7. 合成事件，如：compositionstart
8. 变动事件，如：DOMsubtreeModified

## JS中的垃圾回收机制

[JS 从内存空间谈到垃圾回收机制](https://www.cnblogs.com/echolun/p/11503915.html)

## JS语言的特性

- 运行在客户端浏览器上
- 不用预编译，浏览器直接解析执行代码
- 弱类型语言，较为灵活
- 与操作系统无关，跨平台语言
- 脚本语言，解释性语言

## 同源策略，跨域

[浏览器同源策略及跨域的解决方法](https://juejin.cn/post/6844903681683357710)

## HTTP协议和HTTPS协议

1. `http` 是超文本传输协议，信息是明文传输，`https` 则是具有安全性的ssl加密传输协议。

2. `http` 和 `https` 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

3. `http` 的连接很简单，是无状态的；`HTTPS` 协议是由 `SSL+HTTP` 协议构建的可进行加密传输、身份认证的网络协议，比 `http` 协议安全。

## 常见 http 状态码

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 100    | 告诉客户端继续发送请求，服务器返回此状态表示已收到第一部分请求，正在等待其余部分 |
| 101    | 客户端要求服务器切换协议，服务器已确认并准备切换             |
| 200    | 服务器已成功处理了请求                                       |
| 201    | 请求成功并且服务器创建了新的资源                             |
| 202    | 服务器已接受请求，但尚未处理                                 |
| 203    | 服务器已成功处理了请求，但返回的信息可能来自另一个源         |
| 204    | 服务器成功处理了请求，但没有返回任何内容                     |
| 206    | 服务器成功处理了部分GET请求                                  |
| 301    | （永久重定向）请求的网页以永久移动到新位置                   |
| 302    | （临时重定向）临时从旧地址A跳转到地址B                       |
| 304    | 资源已找到，但是不满足条件，所以不把资源返回给客户端。常用于协商缓存 |
| 400    | 请求报文内有语法错误                                         |
| 401    | 请求要求身份验证                                             |
| 403    | 请求资源的访问被服务器拒绝，一般是访问权限出现问题           |
| 404    | 服务器上找不到资源或路径错误                                 |
| 405    | 请求方法未被服务端识别                                       |
| 500    | 服务器端在请求时出错                                         |
| 502    | 代理服务器或网关从上游服务器中收到无效响应                   |
| 503    | 服务器暂时处于超负载或停机维护，目前无法处理请求             |

**301和302的区别：**

​		301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的 `Location` 首部中获取（**用户看到的效果就是他输入的地址A瞬间变成了另一个地址B**）——**这是它们的共同点**。
  	他们的不同在于。301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301

**重定向原因：**

1. 网站调整（如改变网页目录结构）；
2. 网页被移到一个新地址；
3. 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。

## 懒加载 预加载

### 懒加载

**懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式**。用户滚动到它们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。

**懒加载实现原理**

首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中， 当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。

### 预加载

资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。**预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源**。

在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。

**实现预加载的几种办法：**

1. 使用 HTML 标签

    ```html
    <img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/>
    ```

2. 使用 Image 对象

    ```javascript
    var image= new Image()
    image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg"
    ```

3. 使用 XMLHttpRequest 对象，虽然存在跨域，但会精细控制与加载过程

4. 使用 PreloadJS 库

**懒加载和预加载的对比：**

两者都是提高页面性能有效的办法，**两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力**。

## 前端安全

### 1. CSRF 跨站请求伪造

攻击者盗用了用户的身份，以该用户的名义进行恶意请求。它能做的事情有很多包括：以该用户的名义发邮件、发信息、盗取账号、购买商品、虚拟货币转账等。总结就是：个人隐私暴露及财产安全问题。

```html
阐述 CSRF 攻击思想：（核心2、3）
1. 浏览并登录信任网站（举例：淘宝）
2. 登录成功后在浏览器产生存储（举例：cookie）
3. 用户在没有登出淘宝的情况下，访问危险网站
4. 危险网站中存在恶意代码，代码为发送一个恶意请求（举例：购买商品、余额转账）
5. 携带刚刚在浏览器产生的信息进行恶意请求
6. 淘宝验证为合法请求（区分不出是否是该用户发送）
7. 达到恶意目标
```

**防御措施**

- 涉及到数据修改操作严格使用 `post` 请求而不是 `get` 请求
- `http`协议中使用 `Referer` 属性来确定请求来源进行过滤（禁止外域）
- 请求地址添加 `token`，使黑客无法伪造请求（推荐）
- `http` 头自定义属性验证（推荐）
- 显示验证方式：添加验证码、密码

### 2. XSS 跨站脚本攻击

攻击者在目标网站植入恶意脚本（`js/html`），用户在浏览器上运行时可以获取用户敏感信息（`cookie/session`）、修改 `web` 页面以欺骗用户、与其他漏洞相结合形成蠕虫等。

**XSS类型**

- 持久型XSS：将脚本植入到服务器上，从而导致每个访问的用户都会执行
- 非持久型XSS：对个体用户某 `url` 的参数进行修改

**防御措施（对用户输入内容和服务器返回内容进行过滤和转译）**

- 现代大部分浏览器都自带 XSS 筛选器，vue / react 等成熟框架也对 XSS 进行一些防护

- 即便如此，我们在开发时也要注意和小心

- 对用户输入内容和服务端返回内容进行过滤和转译

- 重要内容加密传输

- 合理使用get/post等请求方式

- 对于URL携带参数谨慎使用

- 我们无法做到彻底阻止，但是能增加黑客攻击成本，当成本与利益不符时自然会降低风险

### 3. CDN劫持

出于性能考虑，前端应用通常会把一些静态资源存放到 `CDN` 上面，例如 `js` 脚本和 `style` 文件。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全问题。如果攻击者劫持了 `CDN`，或者对 `CDN`中的资源进行了污染，攻击者可以肆意篡改我们的前端页面，对用户实施攻击。

现在的 `CDN`以支持 `SRI` 为荣，`script` 和 `link` 标签有了新的属性 `integrity` ，这个属性是为了防止校验完整性来判断是否被篡改。他通过 **验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改**

使用 `SRI` 需要两个条件：一是要保证 **资源同域** 或开启跨域，二是在 `<script>` 中 **提供签名** 以供校验。

```javascript
<script
	crossorigin="anonymous"
	integrity="sha384-xBuQ/xzmlsLoHpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHiW2I5f"
	src="http://lib.baomitu.com/jquery/3.2.1/jquery.min.js"
```

> `integrity` 属性分为两个部分，第一个部分是指定哈希值的生成算法（例如：sha384），第二个部分是经过编码的实际哈希值，两者之间用一个短横（-）来分隔。

这个属性存在兼容性问题

![img](https://pic2.zhimg.com/80/v2-b261b0bffcdf1d30d10c84bdccbe78a9_720w.jpg)

## SEO

**什么是SEO：**

搜索引擎优化（`Search Engine Optimization`），简称 `SEO`，简单的说，为了让你的网站在搜索引擎的结果中排名更靠前（当然充钱也行）

**前端如何进行SEO：**

1. `<head>`标签放网页的标题，各个页面不同。
2. `<meta keywords>`列举出几个重要的关键词。
3. `<meta description>`网页内容的高度概括。
4. `html` 语义化。例如我们要做一个导航，如果使用`div`+`span`，毫无语义化，推荐使用 `ul+li`标记。再通过合适的 `css` 样式来实现效果。
5. `<a>`标记要加上说明（`title`属性），对于指向外部网站的链接要使用`rel="nofollow"`属性告诉爬虫不要去爬其他的页面。
6. `<h1>`正文标题要使用`<h1>`标记，副标题要使用`<h2>`。可以使用CSS样式进行显式风格的设置。切记：*不重要的地方不要随便使用`<h1>`标记*。
7. `<table>`标记的优化。使用`<caption>`标记为表格指定标题。
8. 强调网页中的重要内容应该使用`<strong>`标记，避免使用`<b>`标记（对搜索引擎不友好）。`<em>`的权重仅次于`<strong>`。如果仅仅使显示的效果发生变化就使用`<b>`标记和`<i>`标记。
9. 对于暂时不需要显示的元素应该使用`z-index`属性而不是`display:none;`这样的代码，因为Spider会过滤`display`属性为`none`的内容。

## use strict

设立"严格模式"的目的，主要有以下几个：

- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的Javascript做好铺垫。

## js异步加载的方式

[网页性能优化之异步加载js文件](https://juejin.cn/post/6844903696875126798)

正常的网页加载`js`脚本流程如下：

1. 浏览器一边下载`html`网页，一边开始解析；
2. 解析过程中，浏览器发现`<script>`元素，就暂停解析，把网页渲染的控制权转交给`JavaScript`引擎；
3. 如果`<script>`元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码；
4. `JavaScript`引擎执行完毕，控制权交还给渲染引擎，恢复解析`html`网页。

> 加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 `JavaScript` 代码可以修改 `DOM`，所以必须把控制权让给它，否则会导致复杂的线程竞塞的问题。

> 上面所说的，就是我们平时最常见到的，将`<script>`标签放到`<head>`中的做法，这样的加载方式叫做**同步加载**，或者叫阻塞加载，因为在加载`js`脚本文件时，会阻塞浏览器解析`HTML`文档，等到下载并执行完毕之后，才会接着解析`HTML`文档。如果加载时间过长（比如下载时间太长），就会造成浏览器“假死”，页面一片空白。而且，放在`<head>`中同步加载的`js`文件中不能对`DOM`进行操作，否则会产生错误，因为这个时候`HTML`还没有进行解析，`DOM`还没有生成。由此看来，同步加载带来的体验往往并不好。

**下面是几种异步加载`js`的方式：**

**1. 将 `<script>` 标签放到 `<body>` 底部**

将 `<script>` 放到 `<body>` 底部，解决上上面说到的几个问题，一是不会造成页面解析的阻塞，就算加载时间过长用户也可以看到页面而不是一片空白，而且这时候可以在脚本中操作 `DOM`。

> 严格来讲，这种方式并不算是异步加载，但是这也是常见的通过改变 `js` 加载方式来提升页面性能的一种方式

**2. `defer` 属性**

通过给 `<script>` 标签设置 `defer` 属性，将脚本文件设置为延迟加载，当浏览器遇到带有 `defer` 属性的 `<script>` 标签时，会再开启一个线程去下载 `js` 文件，同时继续解析 `html` 文档，等 `html` 全部解析完毕 `dom` 加载完层之后，再去执行加载好的 `js` 文件。

这种方法只适用于引用外部 `js` 文件的 `<script>` 标签，可以保证多个 `js` 文件的执行顺序就是他们在页面中出现的顺序。

**3. `async` 属性**

`async` 属性和 `defer` 属性类似，也是会开启一个线程去下载 `js` 文件，但和 `defer` 不同的是，`async` 会在下载完成后立即执行，而不会等 `DOM` 加载完成之后再执行，所以还是有可能会造成阻塞。

`async` 也只适用于外部 `js` 文件，对于多个带有 `async` 的 `js` 文件，他不能像 `defer` 那样保证按顺序执行，`async` 方式是哪个 `js` 文件先下载完就先执行。

> 如果要保证脚本之间的执行顺序，应当使用 `defer`，不需要保证执行顺序的话用 `async`，如果同时使用的话，`defer`会失效。

![同步加载、defer、async的区别](https://user-gold-cdn.xitu.io/2018/10/22/1669b730c2f91525?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**4.动态创建 `<script>` 标签**

```javascript
(function(){
    var scriptEle = document.createElement("script");
    scriptEle.type = "text/javasctipt";
    scriptEle.async = true;
    scriptEle.src = "http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js";
    var x = document.getElementsByTagName("head")[0];
    x.insertBefore(scriptEle, x.firstChild); 
})();
```

## 事件循环、宏任务 微任务

[JavaScript中的Event Loop（事件循环）机制](https://segmentfault.com/a/1190000022805523)

## 如果一段 JS 执行时间非常长，怎么分析

[Chrome Performance 页面性能分析指南](https://juejin.cn/post/6850418121548365831)

## axios 的拦截器

[axios拦截器](https://juejin.cn/post/6844903906191867912)

## npm安装机制

[介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22)

## 有以下三个判断数组的方法，介绍他们的区别和优劣。Object.prototype.toString.call()、instanceof、Array.isArray()

[有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/23)

## 模块化发展的历程

[js模块化发展历程 总结](https://juejin.cn/post/6844903986206605320)

## 为什么 VUE 3 采用了 Proxy ，抛弃了 Object.defineProperty

[参考](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90)

## TCP 和 UDP的区别

1. TCP 是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。
2. TCP 提供可靠的服务，通过TCP链接传送的数据，无差错，不丢失，且按序到达。UDP是尽最大努力交付，不保证可靠交付。因为TCP可靠，面向连接，不会丢失数据因此适合大数据量的交换
3. TCP是面向字节流，UDP是面向报文
4. TCP只能是1对1，UDP支持1对1,1对多
5. TCP首部较大为20字节，UDP只有8字节
6. TCP是面向连接的可靠性传输，UDP是不可靠的

## 响应式布局的常用解决方案对比

[响应式布局的常用解决方案对比](https://github.com/forthealllight/blog/issues/13)

## http 常用请求头

[常用的http请求头以及响应头详解](https://www.pianshen.com/article/33571218055/)

## HTTP 的15个常见知识点复习

[HTTP 的15个常见知识点复习](https://juejin.cn/post/6844903872935247886#heading-23)

## flutter有了解过吗？为什么说它的性能可以媲美原生？它有什么缺点吗？

## 浏览器进程

