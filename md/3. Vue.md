## Vue的优点？Vue的缺点？

**优点：**渐进式、组件化、轻量级、虚拟 `dom` 、响应式、单页面路由、数据与视图分开。

**缺点：**单页面不利于 `seo`，不支持 `IE8` 以下，首屏加载时间长。

## 为什么说 Vue 是一个渐进式的框架？

通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用 `component` 就用，不用也行，你想用 `vuex `就用，不用也可以。

## Vue跟React的异同点？

相同点：

- 都使用了虚拟 `dom`
- 组件化开发
- 都是单向数据流(父子组件之间，不建议子修改父传下来的数据)
- 都支持服务端渲染

不同点：

- `React` 的 `JSX` ，`Vue` 的 `template`
- 数据变化，`React` 手动( `setState` )，`Vue`自动(初始化已响应式处理， `Object.defineProperty` )
- `React` 单向绑定，`Vue` 双向绑定
- `React` 的 `Redux` ，`Vue` 的 `Vuex`

## MVVM是什么？和MVC有何区别呢？

### MVC：

- Model（模型）：负责从数据库中取数据；
- View（视图）：负责展示数据的地方；
- Controller（控制器）：用户交互的地方

**思想：** `Controller` 将 `Model` 的数据展示在 `View` 上。

### MVVM：

- VM：也就是 `View-Model` ，做了两件事达到了数据的双向绑定，

    一是将 【模型】转化为【视图】，即把后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。

    二是将【视图】转化为【模型】，即把所看到的页面转化为后端的数据。实现方式是：DOM 事件监听。

    **思想：**实现了 `View` 和 `Model` 的自动同步，也就是当 `Model` 的属性改变时，我们不用再自己手动操作 `DOM` 元素，来改变 `View` 的显示，而是改变属性后，该属性对应 `View` 层显示会自动改变（对应 `Vue` 数据驱动的思想）。

### 区别：

整体看来，`MVVM` 比 `MVC ` 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再操作 `DOM` 。因为在 `MVVM` 中，`View` 不知道 `Model` 的存在， `Model` 和 `ViewModel` 也观察不到 `View` ，这种低耦合模式提高了代码的可重用性。

### Vue 是不是 MVVM框架

`Vue` 是 `MVVM`框架，但不是严格符合 `MVVM` ，因为 `MVVM` 规定 `Model` 和 `View` 不能直接通信，而 `Vue` 的 `ref` 可以做到这一点。

## Vue 和 JQuery 的区别在哪里？

- `JQuery` 是直接操作 `DOM` ，`Vue` 不直接操作 `DOM` ， `Vue` 不直接操作 `DOM` ，`Vue` 的数据与视图是分开的， `Vue` 只需要操作数据即可。
- `JQuery` 操作 `DOM` 的行为是频繁的，而 `Vue` 利用虚拟 `DOM` 技术，大大提高了更新 `DOM` 时的性能。
- `Vue` 中不倡导直接操作 `DOM` ，开发者只需要把大部分精力放在数据层面上。
- `Vue` 集成的一些库，大大提高开发效率，比如 `Vuex`，`Router` 等。

## 为什么 data 是一个函数并且返回一个对象？

对象为引用类型，当复用组件时，由于数据对象都指向同一个 `data` 对象，当在一个组件中修改`data` 时，其他重用的组件中的 `data` 会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（`Object` 的实例），引用地址不同，则不会出现这个问题。

## Vue 的修饰符

1. `.lazy` ：作用是改变输入框的值时 `value` 不会改变，当光标离开输入框时，`v-model` 绑定的值 `value` 才会改变。

2. `.trim` ：作用类似于 `JavaScript` 中的 `trim()` 方法，作用是把 `v-model` 绑定的值的首尾空格过滤掉。

3. `.number` ：作用是将值转换为数字，但是先输入字符串和先输入数字，是两种情况。

    - 先输入数字，再输入字符串，只会取前面数字部分。
    - 先输入字母，再输入数字， `.number` 修饰符无效，字母和数字都会取到。

    只想要取数字的话，可配合 `type="number"` 一同使用。

4. `.stop`：阻止冒泡

5. `.capture`：事件默认是有里往外**冒泡**，`capture` 修饰符的作用是反过来，由外往里**捕获**。

    ```javascript
    <div @click.capture="clickEvent(2)">
        <button @click="clickEvent(1)">点击</button>
    </div>
    
    methods: {
        clickEvent(num) {
            // 不加 capture 点击按钮输出 1 2
            // 加了 capture 点击按钮输出 2 1
            console.log(num)
        }
    }
    ```

6. `.self` ：作用是只有点击时间绑定的本身才会触发事件

    ```javascript
    <div @click.self="clickEvent(2)">
        <button @click="clickEvent(1)">点击</button>
    </div>
    
    methods: {
        clickEvent(num) {
            // 不加 self 点击按钮输出 1 2
            // 加了 self 点击按钮输出 1 点击div才会输出 2
            console.log(num)
        }
    }
    ```

7. `.once` ：作用是事件只执行一次。

8. `.prevent`：作用是阻止默认事件（例如 `a` 标签的跳转）

9. `.native` ：加在自定义组件的事件上，保证事件能正常执行。

    ```javascript
    // 执行不了
    <My-component @click="shout(3)"></My-component>
    
    // 可以执行
    <My-component @click.native="shout(3)"></My-component>
    ```

10. `.left` `.right` `.middle`：鼠标的左中右按键触发的事件。

11. `.passive` ：当我们在监听元素滚动事件的时候，会一直触发 `onscroll` 事件，在 `pc` 端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给 `onscroll` 事件整了一个 `.lazy` 修饰符。

12. `.camel`：

    ```javascript
    // 不加camel viewBox会被识别成viewbox
    <svg :viewBox="viewBox"></svg>
    
    // 加了canmel viewBox才会被识别成viewBox
    <svg :viewBox.camel="viewBox"></svg>
    ```

13. `.sync` ：当父组件传值进子组件时，子组件想要改变这个值时，可以这么做

    ```javascript
    // 父组件里
    <children :foo="bar" @update:foo="val => bar = val"></children>
    
    // 子组件里
    this.$emit('update:foo', newValue)
    ```

    `.sync` 的作用就是，可以简写：

    ```javascript
    // 父组件里
    <children :foo.sync="bar"></children>
    
    // 子组件里
    this.$emit('update:foo', newValue)
    ```

14. `.keyCode`：限制某个按键触发事件。

    ```javascript
    // 按 ctrl 才会触发
    <input type="text" @keyup.ctrl="shout(4)">
        
    //普通键
    .enter
    .tab
    .delete //(捕获“删除”和“退格”键)
    .space
    .esc
    .up
    .down
    .left
    .right
    //系统修饰键
    .ctrl
    .alt
    .meta
    .shift
    ```

## Vue 内部指令

1. `v-text` ：更新元素的 `textContext` ，如果要更新部分的 `textContent` ，需要使用 `{{Mustache}}` 插值。

    ```html
    <span v-text="msg"></span>
    <!-- 和下面的一样 -->
    <span>{{msg}}</span>
    ```

2. `v-html` ：更新元素的 `innerHTML` ，**注意：内容按普通HTML插入-不会作为Vue模板进行编辑**。

    > 在网站上动态渲染任意HTML是非常危险的，因为容易导致 XSS攻击，只在可信内容上使用 v-html，永不在用户提交的内容上。

3. `v-show` ：根据条件展示元素，类似于 `css` 的 `display` 。

4. `v-if` ：根据条件渲染元素。

    `v-if` vs `v-show` ：

    - `v-if` 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当的被销毁和重建。
    - `v-if` 也是惰性的：如果在初次渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
    - 相比之下， `v-show` 不管条件是什么，元素总是会被渲染，并且只是简单的基于 `CSS` 进行切换。
    - 一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁的切换，则使用 `v-show` 更好；如果运行时条件很少改变，则使用 `v-if` 更好。

5. `v-else` ：表示 `v-if` 的 `else` 块，`v-else` 必须紧跟在带 `v-if` 或者 `v-else-if` 的元素后面，否则他将不会被识别。

6. `v-else-if` ：充当 `v-if` 的 `else-if` 块，`v-else-if` 必须紧跟在带 `v-if` 或者 `v-else-if` 元素之后。

    ```html
    <div v-if="type === 'A'">A</div>
    <div v-else-if="type === 'B'">B</div>
    <div v-else>Not A/B</div>
    ```

7. `v-for` ：列表循环渲染。使用 `item in items` 形式的特殊语法。也可以使用  `of` 替代 `in` 作为分隔符，`<div v-for="item of items"></div>` 。

    也可以使用 `v-for` 来遍历一个对象的 `property` 

    ```html
    <div v-for="(value, name, index) in object">
      {{index}}. {{ name }}: {{ value }}
    </div>
    
    object: {
    	name: "zdh",
    	age: 18
    }
    
    // 0.name: zdh
    // 1.age: 18
    ```

8. `v-on` ：监听 `DOM` 事件，缩写 `@`。

9. `v-bind` ：动态绑定各种变量，缩写 `:` 。

10. `v-model` ：双向绑定表单项的值。

11. `v-slot` ：插槽，缩写 `#`。

12. `v-once` ：只渲染元素或者组件**一次**，随后的重新渲染，该元素或组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能，把一些不更新的内容用 `v-once` 属性只计算一次然后缓存起来。

13. `v-pre` ：跳过这个元素和它的子元素的编译过程。可以用来显示原始 `Mustache` 标签，跳过大量没有指令的节点会加快编译。

    ```html
    <!-- v-pre -->
    <span v-pre>{{ this will not be compiled }}</span>
    <!-- 页面直接显示 -->
    {{ this will not be compiled }}
    ```

14. `v-cloak` ：这个指令保持在元素上直到关联实例结束编译。

    当网络较慢时，网页还在加载 `Vue.js`，而导致 `Vue` 来不及渲染，这是网页就会显示出 `Vue` 的源代码，闪一下然后显示文本。可以使用 `v-cloak` 解决这一问题。

    ```html
    <div id="app" v-cloak>
        {{context}}
    </div>
    
    <style>
    [v-cloak]{
        display: none;
    }
    </style>
    ```

## 组件之间传值的方式

1. 父组件传值给子组件，子组件使用 `props` 进行接收。

2. 子组件传值给父组件，子组件使用 `$emit`+事件 对父组件进行传值。

3. 组件中可以使用 `$parent` 和 `$children` 获取到父组件实例和子组件实例。

    > `$children` 并不保证顺序，也不是响应式的。
    >
    > **节制的使用 `$parent` 和  `$children` ，它们的主要目的是作为访问组件的应急方法，更推荐用 `props` 和 `$emit` 实现父子组件通信**

4. 父亲-孙子组件相互传值：`$attrs` 、 `$listeners`。

    [vue组件传值——`$attrs`和`$listeners`](https://www.cnblogs.com/badaozongcai/articles/12791262.html)

5. 使用 `$refs` 获取组件实例，进而获取数据。

6. 使用 `Vuex` 进行状态管理。

7. 使用`eventBus` 事件总线进行跨组件触发事件（兄弟组件），进而传递数据。

    > 这种方式在组件间传值太方便了，会造成难以维护的“灾难”，因此需要更完善的 `Vuex` 作为状态管理。

    [Vue事件总线（EventBus）使用详细介绍](https://zhuanlan.zhihu.com/p/72777951)

8. 使用 `provide` 和 `inject` ，官方不推荐直接用于应用程序中，一般场景是自定义组件库的时候，底层组件之间需要通信的时候使用。

    [Vue 依赖注入 - Provide/Inject](https://www.jianshu.com/p/6651dccd282c)

9. 浏览器本地缓存，例如 `localStorage`。





