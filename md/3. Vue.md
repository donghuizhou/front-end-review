## Vue的优点？Vue的缺点？

**优点：**渐进式、组件化、轻量级、虚拟 `dom` 、响应式、单页面路由、数据与视图分开。

**缺点：**单页面不利于 `seo`，不支持 `IE8` 以下，首屏加载时间长。

## 为什么说 Vue 是一个渐进式的框架？

通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用 `component` 就用，不用也行，你想用 `vuex `就用，不用也可以。

## Vue跟React的异同点？

相同点：

- 都使用了虚拟 `dom`
- 组件化开发
- 都是单向数据流(父子组件之间，不建议子修改父传下来的数据)
- 都支持服务端渲染

不同点：

- `React` 的 `JSX` ，`Vue` 的 `template`
- 数据变化，`React` 手动( `setState` )，`Vue`自动(初始化已响应式处理， `Object.defineProperty` )
- `React` 单向绑定，`Vue` 双向绑定
- `React` 的 `Redux` ，`Vue` 的 `Vuex`

## MVVM是什么？和MVC有何区别呢？

### MVC：

- Model（模型）：负责从数据库中取数据；
- View（视图）：负责展示数据的地方；
- Controller（控制器）：用户交互的地方

**思想：** `Controller` 将 `Model` 的数据展示在 `View` 上。

### MVVM：

- VM：也就是 `View-Model` ，做了两件事达到了数据的双向绑定，

    一是将 【模型】转化为【视图】，即把后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。

    二是将【视图】转化为【模型】，即把所看到的页面转化为后端的数据。实现方式是：DOM 事件监听。

    **思想：**实现了 `View` 和 `Model` 的自动同步，也就是当 `Model` 的属性改变时，我们不用再自己手动操作 `DOM` 元素，来改变 `View` 的显示，而是改变属性后，该属性对应 `View` 层显示会自动改变（对应 `Vue` 数据驱动的思想）。

### 区别：

整体看来，`MVVM` 比 `MVC ` 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再操作 `DOM` 。因为在 `MVVM` 中，`View` 不知道 `Model` 的存在， `Model` 和 `ViewModel` 也观察不到 `View` ，这种低耦合模式提高了代码的可重用性。

### Vue 是不是 MVVM框架

`Vue` 是 `MVVM`框架，但不是严格符合 `MVVM` ，因为 `MVVM` 规定 `Model` 和 `View` 不能直接通信，而 `Vue` 的 `ref` 可以做到这一点。

## Vue 和 JQuery 的区别在哪里？

- `JQuery` 是直接操作 `DOM` ，`Vue` 不直接操作 `DOM` ， `Vue` 不直接操作 `DOM` ，`Vue` 的数据与视图是分开的， `Vue` 只需要操作数据即可。
- `JQuery` 操作 `DOM` 的行为是频繁的，而 `Vue` 利用虚拟 `DOM` 技术，大大提高了更新 `DOM` 时的性能。
- `Vue` 中不倡导直接操作 `DOM` ，开发者只需要把大部分精力放在数据层面上。
- `Vue` 集成的一些库，大大提高开发效率，比如 `Vuex`，`Router` 等。

## 为什么 data 是一个函数并且返回一个对象？

`data` 之所以是一个函数，是因为一个组件可能会被多处调用，而每一次调用就会执行 `data` 函数并返回新的数据对象，这样可以避免多次调用之间的**数据污染**。

## Vue 的修饰符

1. `.lazy` ：作用是改变输入框的值时 `value` 不会改变，当光标离开输入框时，`v-model` 绑定的值 `value` 才会改变。

2. `.trim` ：作用类似于 `JavaScript` 中的 `trim()` 方法，作用是把 `v-model` 绑定的值的首尾空格过滤掉。

3. `.number` ：作用是将值转换为数字，但是先输入字符串和先输入数字，是两种情况。

    - 先输入数字，再输入字符串，只会取前面数字部分。
    - 先输入字母，再输入数字， `.number` 修饰符无效，字母和数字都会取到。

    只想要取数字的话，可配合 `type="number"` 一同使用。

4. `.stop`：阻止冒泡

5. `.capture`：事件默认是有里往外**冒泡**，`capture` 修饰符的作用是反过来，由外往里**捕获**。

    ```javascript
    <div @click.capture="clickEvent(2)">
        <button @click="clickEvent(1)">点击</button>
    </div>
    
    methods: {
        clickEvent(num) {
            // 不加 capture 点击按钮输出 1 2
            // 加了 capture 点击按钮输出 2 1
            console.log(num)
        }
    }
    ```

6. `.self` ：作用是只有点击时间绑定的本身才会触发事件

    ```javascript
    <div @click.self="clickEvent(2)">
        <button @click="clickEvent(1)">点击</button>
    </div>
    
    methods: {
        clickEvent(num) {
            // 不加 self 点击按钮输出 1 2
            // 加了 self 点击按钮输出 1 点击div才会输出 2
            console.log(num)
        }
    }
    ```

7. `.once` ：作用是事件只执行一次。

8. `.prevent`：作用是阻止默认事件（例如 `a` 标签的跳转）

9. `.native` ：加在自定义组件的事件上，保证事件能正常执行。

    ```javascript
    // 执行不了
    <My-component @click="shout(3)"></My-component>
    
    // 可以执行
    <My-component @click.native="shout(3)"></My-component>
    ```

10. `.left` `.right` `.middle`：鼠标的左中右按键触发的事件。

11. `.passive` ：当我们在监听元素滚动事件的时候，会一直触发 `onscroll` 事件，在 `pc` 端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给 `onscroll` 事件整了一个 `.lazy` 修饰符。

12. `.camel`：

    ```javascript
    // 不加camel viewBox会被识别成viewbox
    <svg :viewBox="viewBox"></svg>
    
    // 加了canmel viewBox才会被识别成viewBox
    <svg :viewBox.camel="viewBox"></svg>
    ```

13. `.sync` ：当父组件传值进子组件时，子组件想要改变这个值时，可以这么做

    ```javascript
    // 父组件里
    <children :foo="bar" @update:foo="val => bar = val"></children>
    
    // 子组件里
    this.$emit('update:foo', newValue)
    ```

    `.sync` 的作用就是，可以简写：

    ```javascript
    // 父组件里
    <children :foo.sync="bar"></children>
    
    // 子组件里
    this.$emit('update:foo', newValue)
    ```

14. `.keyCode`：限制某个按键触发事件。

    ```javascript
    // 按 ctrl 才会触发
    <input type="text" @keyup.ctrl="shout(4)">
        
    //普通键
    .enter
    .tab
    .delete //(捕获“删除”和“退格”键)
    .space
    .esc
    .up
    .down
    .left
    .right
    //系统修饰键
    .ctrl
    .alt
    .meta
    .shift
    ```

## Vue 内部指令

