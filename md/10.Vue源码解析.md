[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)

## Vue的庐山真面目

`Vue` 本质上是一个函数，函数上挂了很多原型的方法。有 `Mixin` 混入的方法，还有全局的 `global-api` 。

```javascript
// core/instance/index.js

//...

// Vue 的庐山真面目！其实就是个构造函数，我们只能通过 new Vue 去实例化它
function Vue(options) {
    if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue) ) {
        warn('Vue is a constructor and should be called with the `new` keyword')
    }
    this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

`Vue` 的庐山真面目！其实就是个构造函数，我们只能通过 `new Vue` 去实例化它。

那为什么不用 `ES6` 的 `Class` 去实现呢？因为上述代码中有很多 `xxxMixin` ，并且把 `Vue` 作为参数传入，它们的功能就是给 `Vue` 的 `prototype` 上扩展很多方法。这么做的好处是利于维护和管理。这些是 `Class` 难以实现的。

在初始化的过程中，除了给 `Vue` 的原型上挂载很多方法，还会给 `Vue` 这个对象本身扩展全局的静态方法。

```javascript
// core/index.js
import Vue from './instance/index'

initGlobalAPI(Vue)
```

## new Vue 发生了什么

```javascript
// core/instance/index.js

// ...

// Vue 的庐山真面目！其实就是个构造函数，我们只能通过 new Vue 去实例化它
function Vue(options) {
    // ...
    this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

**我们在 `new Vue` 的时候就进入到 `Vue` 的这个函数中，然后执行 `this._init()` 方法。**

`this._init()` 方法就会做一堆初始化的工作。该方法首先对 `options` 做合并，然后执行一系列例如 `initLiftcycle(vm)` 、`initEvents(vm)` 、`initState(vm)` 等方法。最后调用 `vm.$mount` 方法作挂载。

> 在 `initData()` 方法中，会对 `data` 、`props` 、`methods` 作循环对比，防止它们的属性冲突，因为最终它们都会被挂载到 `vm` 实例上。

## Vue 实例挂载的实现

在 `$mount` 方法中，主要是通过 `el` 拿到节点，然后判断有没有 `render()` 函数和 `template` ，如果没有 `render()` 函数那就会把 `template` 编译成 `render()` 函数，因为 `Vue` 只认 `render()` 方法。

然后调用 `mountComponent()` 方法，该方法就是定义 `updateComponent` 函数，这个函数其实就是一个「渲染 `Watcher` 」。

>  `watcher` 是和响应式原理强相关的一个类，实际上就是一个观察者模式。

## vm._render 方法

`vm._render` 方法主要是通过 `createElement()` 方法最终生成一个 `vnode` 。

> `VNode` 其实是用 `js` 对象来描述一个 `DOM` 节点，它的核心就是几个关键属性，标签名、数据、子节点、键值等，由于 `vnode` 只包含这些属性且无需包含操作 `DOM` 的方法，所以它是非常轻量和简单的，并且 `vnode` 的创建代价比真实 `DOM` 的创建代价小很多。

> `Virtual DOM` 映射到真实的 `DOM` 会经历 `VNode` 的 `create`、`diff`、`patch` 等过程。

那么在 `Vue.js` 中，`VNode` 的创建是通过上面提到的 `createElement` 方法。

## createElement 方法创建 vnode

`createElement` 方法做的第一件事就是把所有的 `children` 处理成一维 `vnode` 数组。然后就是 通过 `new VNode` 生成 `vnode` 。最后把 `vnode` 返回给 `render()` 方法。

## update 方法生成真实的 DOM

`update` 的作用就是把 `vnode` 渲染成真实的 `DOM` 。主要是调用 `patch` 方法。

`update` 的调用时机有两个：

- 一个是首次渲染的时候；
- 一个是数据更新的时候。

```javascript
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    if (!prevVnode) {
        // 首次渲染时，patch方法的第一个参数是真实的DOM，第二个参数是 virtual DOM
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
    } else {
        // 视图更新时，patch方法的2个参数都是virtual DOM
        vm.$el = vm.__patch__(prevVnode, vnode)
    }
}
```

创建过程中，如果 `vnode` 有「子节点」，就先创建「子节点」然后再插入到「父节点」中。

真实的插入 `DOM` 是用 `insert()` 方法。

## 初始化Vue到最终渲染的过程图

<img src="https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png" alt="img" style="zoom: 67%;" />

## createComponent 创建子组件

1. 组件的构造器继承于 `Vue` ，这样子组件就拥有了 `Vue` 的很多能力；

2. 注册组件的钩子函数；

3. 通过 `new VNode` 实例化组件的 `vnode` ，它的名字是以 `vue-component-` 开头

    >  组件 vnode 的 children 是空，主要是后面 patch 过程有用。

## 生命周期

```javascript
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm)
initState(vm)
initProvide(vm)
callHook(vm, 'created')
```

`beforeDestroy` 是「先父后子」，`destroyed` 是「先子后父」。

## 响应式原理

可以简单地认为，一个对象的属性如果拥有了 `getter` 和 `setter` ，那它就是一个响应式对象。

**Observe**：可以理解为是「观察者」这样一个东西

```javascript
export class Observer {
    constructor(value: any) {
        // 1. 缓存 value
        this.value = value
        // 2. 实例化 Dep
        this.dep = new Dep()
        // 3. def 方法的作用就是给 value 添加 __ob__ 属性，__ob__ 不可枚举
        //    并且 __ob__ 的值指向当前的 Object 实例
        def(value, '__ob__', this)
        if (Array.isArray(value)) {
            this.observeArray(value)
        } else {
            this.walk(value)
        }
    }
}
```

**defineReactive：**该方法就是把对象的属性变成响应式

```javascript
export function defineReactive(...) {
    ...
    const dep = new Dep()
    ...
    // 递归这个属性，如果该属性的children也是个对象
    // 那把children也变成响应式对象
    let childOb = !shallow && observe(val)
    Object.defineProperty(obj, key, {
        // 当访问对象的属性时会触发getter
        // getter 做一些依赖收集的事情
        get: function reactiveGetter() {
            ...
        },
        // 当设置对象的属性时会触发setter
        // setter 做一些派发更新的事情
        set: function reactiveSetter(newVal) {
            ...
        }
    })
}
```

**总结：**

- 响应式对象的核心是利用 `Object.defineProperty` 给对象的属性添加 `getter` 和 `setter` 。
- 把 `props` 和 `data` 变成响应式对象的过程中，如果发现子属性也是对象，则会递归的把子属性也变成响应式。

## 依赖收集

访问一个对象的属性时，会触发 `getter` ，这个过程中就会完成「依赖收集」。

```javascript
Object.defineProperty(obj, key, {
    get: function reactiveGetter() {
        const value = getter ? getter.call(obj) : val
        // 下面这个逻辑就是做依赖收集的过程
        if (Dep.target) {
            dep.depend()
            if (childOb) {
                childOb.dep.depend()
                if (Array.isArray(value)) {
                    dependArray(value)
                }
            }
        }
        return value
    }
})
```

### Dep

```javascript
export default class Dep {
    static target: ?Watcher;
    id: number;
    subs: Array<Watcher>;

    constructor() {
        this.id = uid++
        this.subs = []
    }
    addSub(sub: Watcher) {
        this.subs.push(sub)
    }
    depend() {
        if (Dep.target) {
            Dep.target.addDep(this)
        }
    }
}
```

几个概念：

- `Dep` 是一个类，它的作用就是**建立数据和 `Watcher` 之间的桥梁**，`Dep` 是订阅者，`Watcher` 是观察者。

- `Dep.target` 就是一个 `Watcher` 
- `subs` ：订阅数据变化的 `Watcher` 就都会保存到 `subs` 里面

上面「依赖收集」的代码中可以看到，如果 `if (Dep.target)` 为 `true` 的时候，就会调用 `dep.depend()` 方法，该方法就会执行 `Dep.target.addDep(this)` ，也就是执行 `this.subs.push(当前Watcher)` 。

> 这里的 watcher 可以理解为：渲染 watcher 对应的是每一个组件。

**总结：**

- 依赖收集就是订阅数据变化的 `watcher` 的收集。
- 依赖收集的目的是为了，当这些响应式数据发生变化触发它们的 `setter` 的时候，能知道应该通知哪些视图（订阅者）去做相应的处理。

## 派发更新

```javascript
set: function reactiveSetter(newVal) {
    ...
    dep.notify()
}

notify() {
    const subs = this.subs.slice()
	// 遍历所有订阅这个数据的watcher，调用他们的 update 方法
    for (let i = 0, l = subs.length; i < l; i++) {
        subs[i].update()
    }
}
```

`subs[i].update()` 方法最终会走 `queueWatcher()` 函数，这个函数会把所有要更新的 `Watcher` 都推往一个队列。主要是在同一个 `tick` 内，同一个 `watcher` 只会执行一次。最终执行 下面的方法做重新渲染。

```javascript
updateComponent = () => {
    vm._update(vm._render(), hydrating);
}
```







