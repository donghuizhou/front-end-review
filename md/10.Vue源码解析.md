[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)

## Vue的庐山真面目

`Vue` 本质上是一个函数，函数上挂了很多原型的方法。有 `Mixin` 混入的方法，还有全局的 `global-api` 。

```javascript
// core/instance/index.js

//...

// Vue 的庐山真面目！其实就是个构造函数，我们只能通过 new Vue 去实例化它
function Vue(options) {
    if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue) ) {
        warn('Vue is a constructor and should be called with the `new` keyword')
    }
    this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

`Vue` 的庐山真面目！其实就是个构造函数，我们只能通过 `new Vue` 去实例化它。

那为什么不用 `ES6` 的 `Class` 去实现呢？因为上述代码中有很多 `xxxMixin` ，并且把 `Vue` 作为参数传入，它们的功能就是给 `Vue` 的 `prototype` 上扩展很多方法。这么做的好处是利于维护和管理。这些是 `Class` 难以实现的。

在初始化的过程中，除了给 `Vue` 的原型上挂载很多方法，还会给 `Vue` 这个对象本身扩展全局的静态方法。

```javascript
// core/index.js
import Vue from './instance/index'

initGlobalAPI(Vue)
```

## new Vue 发生了什么

```javascript
// core/instance/index.js

// ...

// Vue 的庐山真面目！其实就是个构造函数，我们只能通过 new Vue 去实例化它
function Vue(options) {
    if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue) ) {
        warn('Vue is a constructor and should be called with the `new` keyword')
    }
    this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

我们在 `new Vue` 的时候就进入到 `Vue` 的这个函数中，然后执行 `this._init()` 方法，并将 `options` 传入，`this._init()` 方法是在 `initMixin()` 中定义。

如下面代码，在 `initMixin` 方法中给 `Vue` 的原型上定义了 `_init()` 方法。

`_init()` 方法就做了一堆初始化工作。

```javascript
// core/instance/init.js
export function initMixin(Vue: Class<Component>) {
    // 这里定义 _init 方法
    Vue.prototype._init = function (options?: Object) {
        const vm: Component = this
		...
        // 合并options
        // 这里会把我们传入的 options 最终都 merge 到 $options 上
        // 所以我们可以通过 $options.el 来访问代码中定义的 el
        // 通过 $options.data 访问代码中定义的 data
        if (options && options._isComponent) {
            initInternalComponent(vm, options)
        } else {
            vm.$options = mergeOptions(
                resolveConstructorOptions(vm.constructor),
                options || {},
                vm
            )
        }
        ...
        // 这里是一堆初始化函数，逻辑很清楚
        vm._self = vm
        initLifecycle(vm)
        initEvents(vm)
        initRender(vm)
        callHook(vm, 'beforeCreate')
        initInjections(vm)
        initState(vm)
        initProvide(vm)
        callHook(vm, 'created')
		...
		// 初始化完成后，会判断 $options 中有没有传入 el
        // 调用 $mount 方法挂载 el
        if (vm.$options.el) {
            vm.$mount(vm.$options.el)
        }
    }
}
```

下面代码中为什么在 `mounted` 函数中可以拿到 `this.message`，这里 `Vue` 是做了一些事情的。这里可以看上面 `core/instance/init.js` 中的 `initState(vm)` 方法。该方法在 `core/instance/state.js` 中定义。

```javascript
var app = new Vue({
    el: "#app",
    mounted () {
        console.log(this.message);
    },
    data () {
        return {
            message: "hello"
        }
    }
})
```

```javascript
// core/instance/state.js
export function initState(vm: Component) {
    vm._watchers = []
    const opts = vm.$options
    
    // 初始化 props 和 methods
    if (opts.props) initProps(vm, opts.props)
    if (opts.methods) initMethods(vm, opts.methods)
    if (opts.data) {
        // 重点分析这个 initData() 方法
        initData(vm)
    } else {
        observe(vm._data = {}, true /* asRootData */)
    }
    if (opts.computed) initComputed(vm, opts.computed)
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch)
    }
}
function initData(vm: Component) {
    // 从 vm.$options.data 中拿到 data
    // 也就是上面代码中在 new Vue 时候定义的 data 对象
    let data = vm.$options.data
    // 这里的 data 还赋值给了 vm._data 
    data = vm._data = typeof data === 'function'
        ? getData(data, vm)
        : data || {}
    ...
    // 下面拿到 data 的key
    // 并且拿到 props 和 methods
    // 它们之间会做一个循环对比
    // 如果我们在 data 中定义了变量 message
    // 那么在 props 和 methods 中就不能用 message 这个变量
    // 因为它们最终都会被挂载到 vm 上，也就是当前实例上，所以它们不能有冲突的变量
    // 通过下面的 proxy 方法实现，用 proxy做了一层代理
    const keys = Object.keys(data)
    const props = vm.$options.props
    const methods = vm.$options.methods
    let i = keys.length
    while (i--) {
        const key = keys[i]
        if (process.env.NODE_ENV !== 'production') {
            if (methods && hasOwn(methods, key)) {
                warn(
                    `Method "${key}" has already been defined as a data property.`,
                    vm
                )
            }
        }
        if (props && hasOwn(props, key)) {
            ...
        } else if (!isReserved(key)) {
            proxy(vm, `_data`, key)
        }
    }
    // 这里是做响应式处理，后面再介绍
    observe(data, true /* asRootData */)
}

export function getData(data: Function, vm: Component): any {
    // 这个后面响应式原理的时候再介绍这个方法。
    pushTarget()
    ...
}
const sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
}
export function proxy(target: Object, sourceKey: string, key: string) {
    // 这里的 target 就是传入的 vm，sourceKey 就是传入的 _data
    // 根据下面代码，当我们访问 this.message 的时候，其实就是访问 this._data.message
    sharedPropertyDefinition.get = function proxyGetter() {
        return this[sourceKey][key]
    }
    sharedPropertyDefinition.set = function proxySetter(val) {
        this[sourceKey][key] = val
    }
    Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

上面代码中为什么对变量做 `proxy` 这么一层代理？目的是为了收集依赖和视图更新，通过 `object.defineproperty` 的 `get` 可以收集依赖，`set` 可以触发更新，如果没有代理，这两个过程是没法完成的。

## Vue 实例挂载的实现

在上面讲到的 `core/instance/init.js` 中的 `_init()`方法中，最后面调用了 `vm.$mount(vm.$options.el)`。下面看下这个函数的实现。

```javascript
// entry-runtime-with-compiler
import Vue from './runtime/index'

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
    el?: string | Element,
    hydrating?: boolean
): Component {
    // 这里的 query 方法其实就是调用 document.querySelector 获取 el 节点
    // 这里的 el 被转换成了 dom 对象
    el = el && query(el)

    // 判断 el 节点是不是 body 或者 html，会报错
    // 因为挂载的时候会覆盖el节点，否则会把 body 和 html 整个都覆盖掉
    if (el === document.body || el === document.documentElement) {
        // 报错
        return this
    }

    const options = this.$options
    // 判断有没有 render 函数
    if (!options.render) {
        let template = options.template
        if (template) {
            if (typeof template === 'string') {
                if (template.charAt(0) === '#') {
                    template = idToTemplate(template)
                    if (process.env.NODE_ENV !== 'production' && !template) {
                        warn(
                            `Template element not found or is empty: ${options.template}`,
                            this
                        )
                    }
                }
            } else if (template.nodeType) {
                template = template.innerHTML
            } else {
                if (process.env.NODE_ENV !== 'production') {
                    warn('invalid template option:' + template, this)
                }
                return this
            }
        } else if (el) {
            template = getOuterHTML(el)
        }
        // 上面的这些代码是在获取 dom 节点
        if (template) {
            /* istanbul ignore if */
            if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
                mark('compile')
            }
			// 下面是编译过程
            const { render, staticRenderFns } = compileToFunctions(template, {
                outputSourceRange: process.env.NODE_ENV !== 'production',
                shouldDecodeNewlines,
                shouldDecodeNewlinesForHref,
                delimiters: options.delimiters,
                comments: options.comments
            }, this)
            options.render = render
            options.staticRenderFns = staticRenderFns

            /* istanbul ignore if */
            if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
                mark('compile end')
                measure(`vue ${this._name} compile`, 'compile', 'compile end')
            }
        }
    }
    // 可以看到，Vue 只认render函数，如果有render函数，就直接调用下面的方法
    // 如果没有，就会通过上面的操作转换编译生成render函数
    // 这里的mount方法就是本段代码最上面缓存的 mount方法
    // const mount = Vue.prototype.$mount
    return mount.call(this, el, hydrating)
}
```

**Vue 只认 render 函数**

下面看下被重写覆盖的 `mount` 方法：

```javascript
// platforms/web/runtime/index.js
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

下面看下 `mountCompoent` 方法：

```javascript
// core/instance/lifecycle.js

export function mountComponent(
    vm: Component,
    el: ?Element,
    hydrating?: boolean
): Component {
    // 用 vm.$el 缓存 el
    vm.$el = el
    // 如果没有render函数，并且 上面的 template 没有被正确的转换成 render 函数
    // 那这里就创建一个空的 VNode，createEmptyVNode
    if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode
        // 命中上面这些逻辑，就在开发环境报警告
        if (process.env.NODE_ENV !== 'production') {
            /* istanbul ignore if */
            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
                vm.$options.el || el) {
                warn(
                    'You are using the runtime-only build of Vue where the template ' +
                    'compiler is not available. Either pre-compile the templates into ' +
                    'render functions, or use the compiler-included build.',
                    vm
                )
            } else {
                warn(
                    'Failed to mount component: template or render function not defined.',
                    vm
                )
            }
        }
    }
    callHook(vm, 'beforeMount')

    let updateComponent
    // 下面是 Vue 在做性能埋点
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        updateComponent = () => {
            const name = vm._name
            const id = vm._uid
            const startTag = `vue-perf-start:${id}`
            const endTag = `vue-perf-end:${id}`

            mark(startTag)
            const vnode = vm._render()
            mark(endTag)
            measure(`vue ${name} render`, startTag, endTag)

            mark(startTag)
            vm._update(vnode, hydrating)
            mark(endTag)
            measure(`vue ${name} patch`, startTag, endTag)
        }
    } else {
        updateComponent = () => {
            vm._update(vm._render(), hydrating)
        }
    }
	// 渲染 Watcher,下面有一段代码展示 Watcher 的定义
    new Watcher(vm, updateComponent, noop, {
        before() {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook(vm, 'beforeUpdate')
            }
        }
    }, true /* isRenderWatcher */)
    hydrating = false

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
        vm._isMounted = true
        callHook(vm, 'mounted')
    }
    return vm
}
```

```javascript
// src/core/observer/watcher.js
export default class Watcher {
    ...

    constructor(
        vm: Component,
        expOrFn: string | Function,
        cb: Function,
        options?: ?Object,
        isRenderWatcher?: boolean // 是否是渲染 watcher
    ) {
        this.vm = vm
        if (isRenderWatcher) {
            // 如果是渲染watcher，就在vm上添加 _watcher
            vm._watcher = this
        }
        // 然后 push 进所有的 watchers 里面
        vm._watchers.push(this)
        
        ...
        
        this.expression = process.env.NODE_ENV !== 'production'
            ? expOrFn.toString()
            : ''
        if (typeof expOrFn === 'function') {
            // 这里把 expOrFn 赋值给 this.getter
            // 也就是传入的 updateComponent 函数
            this.getter = expOrFn
        } else {
            ...
        }
        ...
    }
    get() {
        pushTarget(this)
        let value
        const vm = this.vm
        try {
            // 这里执行了 this.getter，也就是执行了传入的 updateComponent 方法
            // 也就是执行上一段代码中的 vm._update(vm._render(), hydrating)
            // vm._update(vm._render(), hydrating) 这里的两个函数就是挂载最终的dom
            // 执行 vm._render() 是生成一个 VNode
            // 然后执行 vm.update() 把 VNode 传入
            value = this.getter.call(vm, vm)
        } catch (e) {
            ...
        } finally {
            ...
        }
        return value
    }
    ...
}
```

总结就是：先对`el` 做一些处理，如果没有定义 `render` 函数，就尝试获取 `render` 函数，把`template` 通过编译的手段转换成 `render ` 函数，然后调用 `mountComponent` 方法， `mountComponent` 方法就是定义 `updateComponent` 函数，这个函数其实就是一个「渲染 `Watcher` 」，`updateComponent` 方法是执行一次真实的渲染，而这个渲染过程，除了首次，在后面更新数据的时候还是会触发「渲染 `Watcher`」再次执行 `updateComponent` 方法，这里是一个 「监听到执行」的过程，这就是「渲染 `Watcher` 」所做的事情。

## render

`render` 方法定义在 `src/core/instance/render.js` 中，`Vue` 的原型上，下面代码的 `renderMixin` 方法中。

```javascript
// src/core/instance/render.js

// initRender 会在 core/instance/init.js 的54行调用执行
export function initRender(vm: Component) {
    ...
    // vm._c 和 vm.$createElement 可以看到它们的区别就是最后一个传入的参数不一样
    // vm._c 是被编译生成的render函数所使用的方法
    // vm.$createElement 是给我们手写的render函数提供了一个创建VNode的方法
    vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
    vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
    ...
}
...
// 可以看到，renderMixin 方法就是返回一个 vnode
export function renderMixin(Vue: Class<Component>) {
    ...
    Vue.prototype._render = function (): VNode {
        const vm: Component = this
        // 从 $options 中拿到 render 函数
        const { render, _parentVnode } = vm.$options
        ...
        vm.$vnode = _parentVnode
        let vnode
        try {
            currentRenderingInstance = vm
            // 下面的 vm._renderProxy 在生产环境下就是vm本身，在开发环境可能是一个 proxy 对象
            // vm.$createElement 在上面定义
            vnode = render.call(vm._renderProxy, vm.$createElement)
        } catch (e) {
            if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
                try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
                } catch (e) {
                    vnode = vm._vnode
                }
            } else {
                vnode = vm._vnode
            }
        }
        if (Array.isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0]
        }
        if (!(vnode instanceof VNode)) {
            ...
            vnode = createEmptyVNode()
        }
        vnode.parent = _parentVnode
        return vnode
    }
}
```

下面看一下 `renderProxy` 是个什么

```javascript
// core/instance/init.js 45行

if (process.env.NODE_ENV !== 'production') {
    initProxy(vm)
} else {
    // 生产阶段直接把vm赋值给vm._renderProxy
    vm._renderProxy = vm
}
```

`initProxy` 的定义在 `src/core/instance/proxy.js` 文件下

```javascript
// src/core/instance/proxy.js

const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy)
initProxy = function initProxy(vm) {
    if (hasProxy) {
        // determine which proxy handler to use
        const options = vm.$options
        const handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler
        vm._renderProxy = new Proxy(vm, handlers)
    } else {
        vm._renderProxy = vm
    }
}
```

## Virtual DOM

其实 `VNode` 是对真实 `DOM` 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 `VNode` 的灵活性以及实现一些特殊 `feature` 的。由于 `VNode` 只是用来映射到真实 `DOM` 的渲染，不需要包含操作 `DOM` 的方法，因此它是非常轻量和简单的。

`Virtual DOM` 除了它的数据结构的定义，映射到真实的 `DOM` 实际上要经历 `VNode` 的 `create`、`diff`、`patch` 等过程。那么在 `Vue.js` 中，`VNode` 的 `create` 是通过之前提到的 `createElement` 方法创建的，我们接下来分析这部分的实现。

## createElement

```javascript
// src/core/vdom/create-element.js

// 可以看到 createElement 最终是调用 _createElement 函数
export function createElement(
    context: Component,
    tag: any,
    data: any,
    children: any,
    normalizationType: any,
    alwaysNormalize: boolean
): VNode | Array<VNode> {
    if (Array.isArray(data) || isPrimitive(data)) {
        normalizationType = children
        children = data
        data = undefined
    }
    if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE
    }
    return _createElement(context, tag, data, children, normalizationType)
}

export function _createElement(
    context: Component,
    tag?: string | Class<Component> | Function | Object,
    data?: VNodeData,
    children?: any,
    normalizationType?: number
): VNode | Array<VNode> {
    // 这里校验 data 不能是个响应式的
    if (isDef(data) && isDef((data: any).__ob__)) {
        ...
        return createEmptyVNode()
    }
    // 对所有的children做 normalize 处理，把children拍平成一维的vnode
    if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children)
    } else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children)
    }
    let vnode, ns
    if (typeof tag === 'string') {
        let Ctor
        ...
        if (config.isReservedTag(tag)) {
            ...
            vnode = new VNode(
                config.parsePlatformTagName(tag), data, children,
                undefined, undefined, context
            )
        } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
            // component
            vnode = createComponent(Ctor, data, context, children, tag)
        } else {
            // unknown or unlisted namespaced elements
            // check at runtime because it may get assigned a namespace when its
            // parent normalizes children
            vnode = new VNode(
                tag, data, children,
                undefined, undefined, context
            )
        }
    } else {
        // direct component options / constructor
        vnode = createComponent(tag, data, context, children)
    }
    if (Array.isArray(vnode)) {
        return vnode
    } else if (isDef(vnode)) {
        if (isDef(ns)) applyNS(vnode, ns)
        if (isDef(data)) registerDeepBindings(data)
        return vnode
    } else {
        return createEmptyVNode()
    }
}
```

## update

`_update` 方式是 `Vue` 实例的私有方法，它的作用就是把 `VNode` 渲染成真实的 `DOM` 。它定义在 `src/core/instance/lifecycle.js` 中。

`update` 的调用时机有两个

- 一个是首次渲染的时候，把 `vnode` 映射成真实的 `DOM` 
- 还有一个就是改变数据的时候，数据的改变也会驱动视图的变化

```javascript
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    // 下面几个变量是给数据改变驱动视图变化用的
    // 所以在第一次调用 update 的时候，可以理解为下面几个变量都是空
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
        prevEl.__vue__ = null
    }
    if (vm.$el) {
        vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
}
```

上面的 `__patch__` 方法是在 `src/platforms/web/runtime/index.js` 中定义的

```javascript
Vue.prototype.__patch__ = inBrowser ? patch : noop
```

上面的 `patch` 方法是在 `src/platforms/web/runtime/patch.js` 中定义：

```javascript
// nodeOps 是实际的 dom 操作
export const patch: Function = createPatchFunction({ nodeOps, modules })
```

`createPatchFunction` 方法最终返回的是一个函数，在 `src/core/vdom/patch.js` 中：

```javascript
function patch(oldVnode, vnode, hydrating, removeOnly) {
    ...
    
    // 这里把真实的dom转换成 vnode
    oldVnode = emptyNodeAt(oldVnode)
    // 创建真实的dom
    createElm(
        vnode,
        insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm,
        nodeOps.nextSibling(oldElm)
    )
}

function createElm(
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
    ) {
    ...
    // 如果这个dom有子节点，就递归调用子节点的 createElm 方法
	createChildren(vnode, children, insertedVnodeQueue)
    // 真实的插入到 dom ，调用的就是insert方法
    insert(parentElm, vnode.elm, refElm)
}
```

在 `core/instance/lifecycle.js` 中，首次调用 `patch` 方法传入

- 第一个参数是真实的 `dom` (`vm.$el`)，而后面再调用 `patch` 的时候，传入的就是 `prevVnode`(虚拟 `dom`)。
- 第二个参数就是渲染生成的 `vdom`

```javascript
if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
} else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
}
```

## 深入响应式原理

在 Vue 的初始化阶段，`_init` 方法执行的时候，会执行 `initState(vm)` 方法。`initState` 方法主要是对 `props`、`methods`、`data`、`computed` 和 `wathcer` 等属性做了初始化操作。

`data` 的初始化主要过程是做两件事，一个是对 `data` 函数返回对象的遍历，通过 `proxy` 把每一个值 `vm._data.xxx` 都代理到 `vm.xxx` 上；另一个是调用 `observe` 方法观测整个 `data` 的变化，把 `data` 变成响应式。

`observe` 的功能就是用来监测数据的变化。
