[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)

## Vue的庐山真面目

`Vue` 本质上是一个函数，函数上挂了很多原型的方法。有 `Mixin` 混入的方法，还有全局的 `global-api` 。

```javascript
// core/instance/index.js

//...

// Vue 的庐山真面目！其实就是个构造函数，我们只能通过 new Vue 去实例化它
function Vue(options) {
    if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue) ) {
        warn('Vue is a constructor and should be called with the `new` keyword')
    }
    this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

`Vue` 的庐山真面目！其实就是个构造函数，我们只能通过 `new Vue` 去实例化它。

那为什么不用 `ES6` 的 `Class` 去实现呢？因为上述代码中有很多 `xxxMixin` ，并且把 `Vue` 作为参数传入，它们的功能就是给 `Vue` 的 `prototype` 上扩展很多方法。这么做的好处是利于维护和管理。这些是 `Class` 难以实现的。

在初始化的过程中，除了给 `Vue` 的原型上挂载很多方法，还会给 `Vue` 这个对象本身扩展全局的静态方法。

```javascript
// core/index.js
import Vue from './instance/index'

initGlobalAPI(Vue)
```

## new Vue 发生了什么

```javascript
// core/instance/index.js

// ...

// Vue 的庐山真面目！其实就是个构造函数，我们只能通过 new Vue 去实例化它
function Vue(options) {
    // ...
    this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

**我们在 `new Vue` 的时候就进入到 `Vue` 的这个函数中，然后执行 `this._init()` 方法。**

`this._init()` 方法就会做一堆初始化的工作。该方法首先对 `options` 做合并，然后执行一系列例如 `initLiftcycle(vm)` 、`initEvents(vm)` 、`initState(vm)` 等方法。最后调用 `vm.$mount` 方法作挂载。

> 在 `initData()` 方法中，会对 `data` 、`props` 、`methods` 作循环对比，防止它们的属性不冲突，因为最终它们都会被挂载到 `vm` 实例上。

## Vue 实例挂载的实现

在 `$mount` 方法中，主要是通过 `el` 拿到节点，然后判断有没有 `render()` 函数和 `template` ，如果没有 `render()` 函数那就会把 `template` 编译成 `render()` 函数，因为 `Vue` 只认 `render()` 方法。

然后调用 `mountComponent()` 方法，该方法就是定义 `updateComponent` 函数，这个函数其实就是一个「渲染 `Watcher` 」。

>  `watcher` 是和响应式原理强相关的一个类，实际上就是一个观察者模式。

## vm._render 方法

`vm._render` 方法主要是通过 `createElement()` 方法最终生成一个 `vnode` 。

## Virtual DOM

 `VNode` 其实是用 `js` 对象来描述一个 `DOM` 节点，它的核心就是几个关键属性，标签名、数据、子节点、键值等，由于 `vnode` 只包含这些属性且无需包含操作 `DOM` 的方法，所以它是非常轻量和简单的，并且 `vnode` 的创建代价比真实 `DOM` 的创建代价小很多。

`Virtual DOM` 映射到真实的 `DOM` 会经历 `VNode` 的 `create`、`diff`、`patch` 等过程。

那么在 `Vue.js` 中，`VNode` 的创建是通过上一节提到的 `createElement` 方法。

## createElement 方法创建 vnode

`createElement` 方法做的第一件事就是把所有的 `children` 处理成一维 `vnode` 数组。然后就是 通过 `new VNode` 生成 `vnode` 。最后把 `vnode` 返回给 `render()` 方法。

## update 方法生成真实的 DOM

`update` 的作用就是把 `vnode` 渲染成真实的 `DOM` 。主要是调用 `patch` 方法。

`update` 的调用时机有两个：

- 一个是首次渲染的时候；
- 一个是数据更新的时候。

```javascript
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    if (!prevVnode) {
        // 首次渲染时，patch方法的第一个参数是真实的DOM，第二个参数是 virtual DOM
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
    } else {
        // 视图更新时，patch方法的2个参数都是virtual DOM
        vm.$el = vm.__patch__(prevVnode, vnode)
    }
}
```

创建过程中，如果 `vnode` 有「子节点」，就先创建「子节点」然后再插入到「父节点」中。

真实的插入 `DOM` 是用 `insert()` 方法。

## 初始化Vue到最终渲染的过程图

<img src="https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png" alt="img" style="zoom: 67%;" />

