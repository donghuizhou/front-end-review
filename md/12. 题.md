## 拦截器请求重发

```javascript
axios.interceptors.response.ues(response => {
    // 如果请求失败或者token失效
    if (...) {
    	// 做些处理
        return axios.request(response.config);
    }
})
```

## 文档碎片

```javascript
const listNode = document.getElementById("list");

// 创建一个文档片段，此时还没有插入到DOM树中
const frag = document.createDocumentFragment();

// 执行插入
for (let x = 0; x < 10; x++) {
  	const li = document.createElement("li");
	li.innerHTML = "List item " + x;
  	frag.appendChild(li);
}

// 都完成之后，再插入到 DOM 树中
listNode.appendChild(frag);

```

## webpack 打包优化

使用 `webpack-bundle-analyzer` 分析打包后文件占比。

1. 升级开发环境，比如升级 `nodejs` 环境、脚手架环境等

2. 缩小文件搜索范围

    - `include`、`exclude`、`test` 配合 `loader` 来限制文件的搜索范围

3. 合理配置 `resolve` ，`resolve` 配置有几个参数：

    - `extensions` ，告诉 `webpack` 在没有写模块后缀的时候，如何查找模块

        ```javascript
        // 书写了模块后缀
        import main from 'main.js'
        
        // 没有书写模块后缀
        import main from 'main'
        ```

        像上面那样，我们不写 `main.js` 的 `.js` 后缀，是因为 `Webpack` 会默认帮我们去查找一些文件。

        ```javascript
        resolve: {
            extensions: ['.js', '.json', '.vue']
        }
        ```

    - `mainFields` ，不写具体的模块名称，`webpack` 也能找到模块

        ```javascript
        // 省略具体模块名称
        import BaseHeader from '@components/base-header/';
        
        // 以上相当于这一段代码
        import BaseHeader from '@components/base-header/index.vue';
        
        resolve: {
            extensions: ['.js', '.json', '.vue'],
                mainFields: ['main', 'index']
        }
        ```

    - 配置别名 `alias` 

        **但是不能过度的使用上面的配置，不然会增加 `webpack` 的查找时间。**

4. `terser-webpack-plugin` 插件可以多进程的压缩 `js` 代码

5. `mini-css-extract-plugin` 插件提取 `css` 代码到单独的文件中，并对 `css` 代码进行压缩

6. `tree shaking` 去掉冗余代码

    ```javascript
    module.exports = {
        // 其它配置
        optimization: {
            usedExports: true
        }
    }
    ```

7. 使用 `split-chunks-plugin` 提取公共代码，实现代码分割

8. `DllPlugin` 减少第三方库的编译次数

9. 利用缓存来减少打包时间

    - `babel-loader` 开启缓存

        ```javascript
        {
        	loader: "babel-loader",
            options: {
                cacheDirectory: true
            }
        }
        ```

    - `cache-loader` 开启缓存，用法非常简单，在开销较大的 `loader` 前使用即可

        ```javascript
        {
            test: /\.js$/,
            use: [
                "cache-loader",
                "babel-loader"
            ],
            include: path.resolve("src")
        }
        ```

10. 使用 `url-loader` 对于小图片使用 `base64` 格式，减少 `http` 请求

11. 合理使用 `hash` ，如果没改动的文件，就会命中缓存。`contenthash`

12. 静态资源可以使用 `CDN` 

## webpack 打包开启压缩

`compression-webpack-plugin`  插件

```javascript
module.exports = {
    configureWebpack: config => {
        if (isProd) {
            // 启用 gzip 压缩插件
            config.plugins.push(
                new CompressionWebpackPlugin({
                	test: /\.js$|\.html$|\.css$/u,
	                threshold: 4096, // 超过 4kb 压缩
            	})
            )
        }
    }
}
```

## js层面的代码优化

1. 一些第三方库使用 `CDN` 引入
2. 代码压缩，代码合并，减少 `http` 请求
3. 利用缓存
4. 非核心代码异步加载，`defer` 和 `async` 
5. `css` 放在 `head` ，`js` 放在 `body` 最下面
6. 图片懒加载
7. 频繁的 `DOM` 操作可以使用，文档碎片减少页面回流
8. 防抖 `debounce` 和 节流 `throttle`
9. 避免内存泄漏
10. 使用 `iconfont` 代替图片图标
11. 当判断条件很多时，使用 `switch` 而不是 `if-else` ，因为 `if-else` 会进行多次判断，而 `switch` 只判断一次
12. 使用事件委托，减少内存
13. 尽量使用 `css3` 动画，开启硬件加速
14. 合理使用 `requestAnimationFrame` ，而不是 `setTimeout` 

## vue3 vite了解

## webpack 在打包过程中删除注释，去除console

删除注释： `terser-webpack-plugin` 中配置 `extractComments: false` 。

删除 `console` ：在 `UglifyJsPlugin` 中配置 `drop_console: true` 。

## keep-alive的组件

设置了 `keep-alive` 缓存的组件，会多出两个生命周期钩子：

- 首次进入组件时：`beforeRouteEnter` > `beforeCreate` > `created` > `mounted` > **`activated`** > ... ... > `beforeRouteLeave` > **`deactivated`**
- 再次进入组件时：`beforeRouteEnter` > **`activated`** > ... ... > `beforeRouteLeave` > **`deactivated`**

缓存的组件中 `activated` 钩子函数每次都会触发。

如果未使用 `keep-alive` 组件，则在页面回退时会重新渲染页面，首次进入组件的一系列生命周期也会一一被触发。

离开组件时，使用了 `keep-alive` 不会调用 `beforeDestroy` 和 `destroyed` 钩子，因为组件没被销毁，被缓存起来了。所以 `deactivated` 这个钩子可以看作是 `beforeDestroy` 和 `destroyed` 的代替